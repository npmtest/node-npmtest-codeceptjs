{"/home/travis/build/npmtest/node-npmtest-codeceptjs/test.js":"/* istanbul instrument in package npmtest_codeceptjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/lib.npmtest_codeceptjs.js":"/* istanbul instrument in package npmtest_codeceptjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_codeceptjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_codeceptjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-codeceptjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_codeceptjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_codeceptjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_codeceptjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_codeceptjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_codeceptjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_codeceptjs.__dirname + '/lib.npmtest_codeceptjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/index.js":"'use strict';\n/**\n * Index file for loading CodeceptJS programmatically.\n *\n * Includes Public API objects\n */\nmodule.exports = {\n  codecept: require('./codecept'),\n  output: require('./output'),\n  container: require('./container'),\n  event: require('./event'),\n  recorder: require('./recorder'),\n  config: require('./config'),\n  actor: require('./actor'),\n  helper: require('./helper'),\n  pause: require('./pause'),\n  within: require('./within')\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/codecept.js":"'use strict';\n\nlet fsPath = require('path');\nlet readFileSync = require('fs').readFileSync;\nlet readdirSync = require('fs').readdirSync;\nlet statSync = require('fs').statSync;\nlet Container = require('./container');\nlet Config = require('./config');\nlet event = require('../lib/event');\nlet glob = require('glob');\nlet fileExists = require('./utils').fileExists;\nlet runHook = require('./hooks');\n\n/**\n * CodeceptJS runner\n */\nclass Codecept {\n\n\n  /**\n   * Create CodeceptJS runner.\n   * Config and options should be passed\n   *\n   * @param {*} config\n   * @param {*} opts\n   */\n  constructor(config, opts) {\n    this.config = config;\n    this.opts = opts;\n    this.testFiles = [];\n  }\n\n  /**\n   * Initialize CodeceptJS at specific directory.\n   * If async initialization is required pass callbacke as second parameter.\n   *\n   * @param {*} dir\n   * @param {*} callback\n   */\n  init(dir, callback) {\n    // preparing globals\n    global.codecept_dir = dir;\n    global.output_dir = fsPath.resolve(dir, this.config.output);\n    global.actor = global.codecept_actor = require('./actor');\n    global.Helper = global.codecept_helper = require('./helper');\n    global.pause = require('./pause');\n    global.within = require('./within');\n\n    // initializing listeners\n    Container.create(this.config, this.opts);\n    this.bootstrap(callback);\n  }\n\n  /**\n   * Executes hooks and bootstrap.\n   * If bootstrap is async second parameter is required.\n   *\n   * @param {*} done\n   */\n  bootstrap(done) {\n\n    // default hooks\n    runHook(require('./listener/steps'));\n    runHook(require('./listener/helpers'));\n    runHook(require('./listener/exit'));\n    runHook(require('./listener/trace'));\n\n    // custom hooks\n    this.config.hooks.forEach((hook) => runHook(hook));\n\n    // bootstrap\n    runHook(this.config.bootstrap, done, 'bootstrap');\n  }\n\n  /**\n   * Executes teardown.\n   * If teardown is async a parameter is provided.\n   *\n   * @param {*} done\n   */\n  teardown(done) {\n    runHook(this.config.teardown, done, 'teardown');\n  }\n\n  /**\n   * Loads tests by pattern or by config.tests\n   *\n   * @param {optional} pattern\n   */\n  loadTests(pattern) {\n    pattern = pattern || this.config.tests;\n    glob.sync(fsPath.resolve(codecept_dir, pattern)).forEach((file) => {\n      this.testFiles.push(fsPath.resolve(file));\n    });\n  }\n\n  /**\n   * Run a specific test or all loaded tests.\n   *\n   * @param {optional} test\n   */\n  run(test) {\n    let mocha = Container.mocha();\n    mocha.files = this.testFiles;\n    if (test) {\n      mocha.files = mocha.files.filter((t) => fsPath.basename(t, '_test.js') === test || fsPath.basename(t, '.js') === test || fsPath.basename(t) === test);\n    }\n    mocha.run().on('end', () => {\n      let done = () => {\n        event.emit(event.all.result, this);\n      };\n      this.teardown(done);\n    });\n  }\n\n\n  static version() {\n    return JSON.parse(readFileSync(__dirname + '/../package.json', 'utf8')).version;\n  }\n}\n\nmodule.exports = Codecept;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/container.js":"'use strict';\nlet path = require('path');\nlet fileExists = require('./utils').fileExists;\nlet Translation = require('./translation');\nlet MochaFactory = require('./mocha_factory');\n\nlet container = {\n  helpers: {},\n  support: {},\n  mocha: {},\n  translation: {},\n};\n\n/**\n * Dependency Injection Container\n */\nclass Container {\n\n  /**\n   * Create container with all required helpers and support objects\n   *\n   * @api\n   * @param {*} config\n   * @param {*} opts\n   */\n  static create(config, opts) {\n    container.mocha = MochaFactory.create(config.mocha || {}, opts || {});\n    container.helpers = createHelpers(config.helpers || {});\n    container.translation = loadTranslation(config.translation || null);\n    container.support = createSupportObjects(config.include || {});\n  }\n\n  /**\n   * Get all support objects or get support object by name\n   *\n   * @api\n   * @param {optional} name\n   */\n  static support(name) {\n    if (!name) {\n      return container.support;\n    }\n    return container.support[name];\n  }\n\n  /**\n   * Get all helpers or get a helper by name\n   *\n   * @api\n   * @param {optional} name\n   */\n  static helpers(name) {\n    if (!name) {\n      return container.helpers;\n    }\n    return container.helpers[name];\n  }\n\n  /**\n   * Get translation\n   *\n   * @api\n   */\n  static translation() {\n    return container.translation;\n  }\n\n  /**\n   * Get Mocha instance\n   *\n   * @api\n   */\n  static mocha() {\n    return container.mocha;\n  }\n\n  /**\n   * Append new services to container\n   *\n   * @api\n   */\n  static append(newContainer) {\n    const deepMerge = require('./utils').deepMerge;\n    container = deepMerge(container, newContainer);\n  }\n\n  /**\n   * Clear container\n   *\n   * @param {*} newHelpers\n   * @param {*} newSupport\n   */\n  static clear(newHelpers, newSupport) {\n    container.helpers = newHelpers || {};\n    container.support = newSupport || {};\n    container.translation = loadTranslation();\n  }\n}\n\nmodule.exports = Container;\n\nfunction createHelpers(config) {\n  let helpers = {};\n  let helperModule;\n  for (let helperName in config) {\n    try {\n      module = config[helperName].require\n        ? path.resolve(global.codecept_dir, config[helperName].require) // custom helper\n        : './helper/' + helperName; // built-in helper\n      let HelperClass = require(module);\n      if (HelperClass._checkRequirements) {\n        let requirements = HelperClass._checkRequirements();\n        if (requirements) {\n          let install;\n          if (require('./utils').installedLocally()) {\n            install = \"npm install --save-dev \" + requirements.join(' ');\n          } else {\n            install = \"[sudo] npm install -g \" + requirements.join(' ');\n          }\n          throw new Error(\"Required modules are not installed.\\n\\nRUN: \" + install);\n        }\n      }\n      helpers[helperName] = new HelperClass(config[helperName]);\n    } catch (err) {\n      throw new Error(`Could not load helper ${helperName} from module '${module}':\\n${err.message}\\n${JSON.stringify(err)}`);\n    }\n  }\n\n  for (let name in helpers) {\n    if (helpers[name]._init) helpers[name]._init();\n  }\n  return helpers;\n}\n\nfunction createSupportObjects(config) {\n  let objects = {};\n  for (let name in config) {\n    let module = config[name];\n    if (module.charAt(0) === '.') {\n      module = path.join(global.codecept_dir, module);\n    }\n    try {\n      objects[name] = require(module);\n    } catch (err) {\n      throw new Error(`Could not include object ${name} from module '${module}'\\n${err.message}`);\n    }\n    try {\n      if (typeof objects[name] === 'function') {\n        objects[name] = objects[name]();\n      } else if (objects[name]._init) {\n        objects[name]._init();\n      }\n    } catch (err) {\n      throw new Error(`Initialization failed for ${objects[name]}\\n${err.message}`);\n    }\n  }\n  if (!objects.I) {\n    objects.I = require('./actor')();\n\n    if (container.translation.I != 'I') {\n      objects[container.translation.I] = objects.I;\n    }\n  }\n\n  return objects;\n}\n\nfunction loadTranslation(translation) {\n  if (!translation) {\n    return new Translation({\n      I: 'I',\n      actions: {}\n    }, false);\n  }\n\n  let vocabulary;\n  // check if it is a known translation\n  if (require('../translations')[translation]) {\n    vocabulary = require('../translations')[translation];\n    return new Translation(vocabulary);\n  } else if (fileExists(path.join(global.codecept_dir, translation))) {\n    // get from a provided file instead\n    vocabulary = require(path.join(global.codecept_dir, translation));\n  } else {\n    throw new Error(`Translation option is set in config, but ${translation} is not a translated locale or filename`);\n  }\n\n  return new Translation(vocabulary);\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/utils.js":"var fs = require('fs');\nvar path = require('path');\nvar getParameterNames = require('get-parameter-names');\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction deepMerge(target, source) {\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    }\n  }\n  return target;\n}\n\nmodule.exports.deepMerge = deepMerge;\n\nmodule.exports.fileExists = function (filePath) {\n  try {\n    fs.statSync(filePath);\n  } catch (err) {\n    if (err.code === 'ENOENT') return false;\n  }\n  return true;\n};\n\nmodule.exports.isFile = function (filePath) {\n  var filestat;\n  try {\n    filestat = fs.statSync(filePath);\n  } catch (err) {\n    if (err.code === 'ENOENT') return false;\n  }\n  if (!filestat) return false;\n  return filestat.isFile();\n};\n\nmodule.exports.getParamNames = function (fn) {\n  if (fn.isSinonProxy) return [];\n  return getParameterNames(fn);\n};\n\nmodule.exports.installedLocally = function () {\n  return path.resolve(__dirname + '/../').indexOf(process.cwd()) === 0;\n};\n\nmodule.exports.methodsOfObject = function (obj, className) {\n  var methods = [];\n\n  const standard = [\n    'constructor',\n    'toString',\n    'toLocaleString',\n    'valueOf',\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable'\n  ];\n\n  while (obj.constructor.name !== className) {\n    Object.getOwnPropertyNames(obj).forEach((prop) => {\n      if (typeof obj[prop] !== 'function') return;\n      if (standard.indexOf(prop) >= 0) return;\n      if (prop.indexOf('_') === 0) return;\n      methods.push(prop);\n    });\n    obj = obj.__proto__;\n\n    if (!obj || !obj.constructor) break;\n  }\n  return methods;\n};\n\nmodule.exports.template = function (template, data) {\n  return template.replace(/{{([^{}]*)}}/g, function (a, b) {\n    var r = data[b];\n    if (r === undefined) return '';\n    return r.toString();\n  });\n};\n\nmodule.exports.ucfirst = function (str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n};\n\nmodule.exports.lcfirst = function (str) {\n  return str.charAt(0).toLowerCase() + str.substr(1);\n};\n\nmodule.exports.hashCode = function (str) {\n  /* Getting 32bit hashCode of string like in Java.\n   *  Used in Screenshot name to provide short screenshot names\n   */\n  var hash = 0;\n  var char;\n  if (str.length == 0) return hash;\n  for (var i = 0; i < str.length; i++) {\n    char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash;\n};\n\nmodule.exports.xpathLocator = {\n  literal: (string) => {\n    if (string.indexOf(\"'\") > -1) {\n      string = string.split(\"'\", -1).map(function (substr) {\n        return \"'\" + substr + \"'\";\n      }).join(',\"\\'\",');\n      return \"concat(\" + string + \")\";\n    } else {\n      return \"'\" + string + \"'\";\n    }\n  },\n  combine: (locators) => {\n    return locators.join(' | ');\n  }\n};\n\nmodule.exports.test = {\n\n  submittedData: function (dataFile) {\n    return function (key) {\n      var data = JSON.parse(fs.readFileSync(dataFile, 'utf8'));\n      if (key) {\n        return data.form[key];\n      }\n      return data;\n    };\n  },\n\n  expectError: function () {\n    throw new Error('should not be thrown');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/translation.js":"'use strict';\n\nclass Translation {\n\n  constructor(vocabulary, loaded) {\n    this.vocabulary = vocabulary;\n    this.loaded = loaded !== false;\n  }\n\n  value(val) {\n    return this.vocabulary[val];\n  }\n\n  actionAliasFor(actualActionName) {\n    if (this.vocabulary.actions && this.vocabulary.actions[actualActionName]) {\n      return this.vocabulary.actions[actualActionName];\n    }\n    return actualActionName;\n  }\n\n  get I() {\n    return this.vocabulary.I;\n  }\n}\n\nmodule.exports = Translation;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/mocha_factory.js":"const Mocha = require('mocha/lib/mocha');\nconst fsPath = require('path');\nconst reporter = require('./reporter/cli');\nconst scenarioUi = fsPath.join(__dirname, './interfaces/bdd.js');\n\nlet mocha;\n\nclass MochaFactory {\n\n  static create(config, opts) {\n    mocha = new Mocha(Object.assign(config, opts));\n\n    mocha.ui(scenarioUi);\n    // use standard reporter\n    if (!opts.reporter) {\n      mocha.reporter(reporter, opts);\n      return mocha;\n    }\n\n    // load custom reporter with options\n    var reporterOptions = Object.assign(config.reporterOptions || {});\n\n    if (opts.reporterOptions !== undefined) {\n      opts.reporterOptions.split(\",\").forEach(function (opt) {\n        var L = opt.split(\"=\");\n        if (L.length > 2 || L.length === 0) {\n          throw new Error(\"invalid reporter option '\" + opt + \"'\");\n        } else if (L.length === 2) {\n          reporterOptions[L[0]] = L[1];\n        } else {\n          reporterOptions[L[0]] = true;\n        }\n      });\n    }\n\n    // custom reporters\n    mocha.reporter(opts.reporter, reporterOptions);\n    return mocha;\n  }\n}\n\nmodule.exports = MochaFactory;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/reporter/cli.js":"'use strict';\n\nlet Base = require('mocha/lib/reporters/base');\nlet ms = require('mocha/lib/ms');\nlet event = require('../event');\nlet AssertionFailedError = require('../assert/error');\nlet output = require('../output');\nlet tests = [];\nlet currentTest;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\nclass Cli extends Base {\n  constructor(runner, opts) {\n    super(runner);\n    let level = 0;\n    if (opts.steps) level = 1;\n    if (opts.debug) level = 2;\n    if (opts.verbose) level = 3;\n\n    output.process(opts.child);\n    output.level(level);\n    output.print('CodeceptJS v' + require('../codecept').version());\n    output.print(`Using test root \"${global.codecept_dir}\"`);\n\n    let showSteps = level >= 1;\n\n    let indents = 0;\n    function indent() {\n      return Array(indents).join('  ');\n    }\n\n    runner.on('start', function () {\n      console.log();\n    });\n\n    runner.on('suite', function (suite) {\n      output.suite.started(suite);\n    });\n\n    runner.on('fail', function (test, err) {\n      if (showSteps && test.steps) {\n        return output.scenario.failed(test);\n      }\n      cursor.CR();\n      output.test.failed(test);\n    });\n\n    runner.on('pending', function (test) {\n      cursor.CR();\n      output.test.skipped(test);\n    });\n\n    runner.on('pass', function (test) {\n      if (showSteps && test.steps) {\n        return output.scenario.passed(test);\n      }\n      cursor.CR();\n      output.test.passed(test);\n    });\n\n    if (showSteps) {\n      runner.on('test', function (test) {\n        if (test.steps) {\n          output.test.started(test);\n        }\n      });\n\n      event.dispatcher.on(event.step.started, function (step) {\n        output.step(step, global.suiteDetails);\n      });\n    }\n\n    runner.on('end', this.result.bind(this));\n  }\n\n  result() {\n    let stats = this.stats;\n    console.log();\n\n    // passes\n    if (stats.failures) {\n      output.print('-- FAILURES:');\n    }\n\n    // failures\n    if (stats.failures) {\n      // append step traces\n      this.failures.forEach((test) => {\n        let err = test.err;\n        if (err instanceof AssertionFailedError) {\n          err.message = err.cliMessage();\n\n          // remove error message from stacktrace\n          var lines = err.stack.split('\\n');\n          lines.splice(0, 1);\n          err.stack = lines.join('\\n');\n        }\n        if (output.level() < 3) {\n          err.stack += `\\n\\nRun with --verbose flag to see NodeJS stacktrace`;\n        }\n      });\n\n      Base.list(this.failures);\n      console.log();\n    }\n\n    output.result(stats.passes, stats.failures, stats.pending, ms(stats.duration));\n  }\n}\nmodule.exports = function (runner, opts) {\n  return new Cli(runner, opts);\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/event.js":"var events = require('events');\nvar dispatcher = new events.EventEmitter();\nvar log = require('./output').log;\n\nmodule.exports = {\n  dispatcher,\n  test: {\n    started: 'test.start',\n    before: 'test.before',\n    after: 'test.after',\n    passed: 'test.passed',\n    failed: 'test.failed',\n  },\n  suite: {\n    before: 'suite.before',\n    after: 'suite.after'\n  },\n  step: {\n    before: 'step.before',\n    started: 'step.start',\n    after: 'step.after'\n  },\n  all: {\n    before: 'global.before',\n    after: 'global.after',\n    result: 'global.result'\n  },\n\n  emit: function (event, param) {\n    var msg = 'Emitted | ' + event;\n    if (param && param.toString()) {\n      msg += ` (${param.toString()})`;\n    }\n    log(msg);\n    try {\n      this.dispatcher.emit.apply(this.dispatcher, arguments);\n    } catch (err) {\n      log(`Error processing ${event} event:`);\n      log(err.stack);\n    }\n  },\n\n  // for testing only!\n  cleanDispatcher: () => {\n    var event;\n    for (event in this.test) {\n      this.dispatcher.removeAllListeners(this.test[event]);\n    }\n    for (event in this.suite) {\n      this.dispatcher.removeAllListeners(this.test[event]);\n    }\n    for (event in this.step) {\n      this.dispatcher.removeAllListeners(this.test[event]);\n    }\n    for (event in this.all) {\n      this.dispatcher.removeAllListeners(this.test[event]);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/output.js":"'use strict';\n\nlet colors = require('chalk');\nlet symbols = require('mocha/lib/reporters/base').symbols;\n\nlet styles = {\n  error: colors.bgRed.white.bold,\n  success: colors.bgGreen.white.bold,\n  scenario: colors.magenta.bold,\n  basic: colors.white,\n  debug: colors.cyan,\n  log: colors.grey\n};\n\nlet outputLevel = 0;\nlet outputProcess = '';\n\nmodule.exports = {\n  colors,\n  styles,\n  print,\n  stepShift: 0,\n\n  /**\n   * Set or return current verbosity level\n   */\n  level: (level) => {\n    if (level) outputLevel = level;\n    return outputLevel;\n  },\n\n  /**\n   * Print information for a process\n   * Used in multiple-run\n   */\n  process: (process) => {\n    if (process) outputProcess = `[${process}]`;\n    return outputProcess;\n  },\n\n  /**\n   * Print information in --debug mode\n   */\n  debug: (msg) => {\n    if (outputLevel >= 2) print(' '.repeat(this.stepShift), styles.debug(\"> \" + msg));\n  },\n\n  /**\n   * Print information in --verbose mode\n   */\n  log: (msg) => {\n    if (outputLevel >= 3) print(' '.repeat(this.stepShift), styles.log(\"  \" + msg));\n  },\n\n  /**\n   * Print error\n   */\n  error: (msg) => {\n    print(styles.error(msg));\n  },\n\n  /**\n   * Print a successful message\n   */\n  success: (msg) => {\n    print(styles.success(msg));\n  },\n\n  /**\n   * Print a step\n   */\n  step: function (step) {\n    if (outputLevel === 0) return;\n    if (!step) return;\n    let sym = process.platform === 'win32' ? '*' : '•';\n    print(' '.repeat(this.stepShift), `${sym} ${step.toString()}`);\n  },\n\n  suite: {\n    started: (suite) => {\n      if (!suite.title) return;\n      print(colors.bold(suite.title) + ' --');\n    }\n  },\n\n  test: {\n    started: (test) => {\n      print(` ${colors.magenta.bold(test.title)}`);\n    },\n    passed: (test) => {\n      print(` ${colors.green.bold(symbols.ok)} ${test.title} ${colors.grey('in ' + test.duration + 'ms')}`);\n    },\n    failed: (test) => {\n      print(` ${colors.red.bold(symbols.err)} ${test.title} ${colors.grey('in ' + test.duration + 'ms')}`);\n    },\n    skipped: (test) => {\n      print(` ${colors.yellow.bold('S')} ${test.title}`);\n    }\n  },\n\n  scenario: {\n    started: (test) => {\n\n    },\n    passed: (test) => {\n      print(' ' + colors.green.bold(`${symbols.ok} OK`) + ' ' + colors.grey(`in ${test.duration}ms`));\n      print();\n    },\n    failed: (test) => {\n      print(' ' + colors.red.bold(`${symbols.err} FAILED`) + ' ' + colors.grey(`in ${test.duration}ms`));\n      print();\n    }\n  },\n\n  say: (message) => {\n    if (outputLevel >= 1) print(`   ${colors.cyan.bold(message)}`);\n  },\n\n  result: (passed, failed, skipped, duration) => {\n    let style = colors.bgGreen;\n    let msg = ` ${passed || 0} passed`;\n    let status = style.bold(`  OK `);\n    if (failed) {\n      style = style.bgRed;\n      status = style.bold(`  FAIL `);\n      msg += `, ${failed} failed`;\n    }\n    status += style.grey(` |`);\n\n    if (skipped) {\n      if (!failed) style = style.bgYellow;\n      msg += `, ${skipped} skipped`;\n    }\n    msg += \"  \";\n    print(status + style(msg) + colors.grey(` // ${duration}`));\n  }\n};\n\nfunction print(...msg) {\n  if (outputProcess) {\n    msg.unshift(outputProcess);\n  }\n  console.log.apply(this, msg);\n}\n\nfunction ind() {\n  return \"  \";\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert/error.js":"'use strict';\nlet subs = require('../utils').template;\n\n/**\n * Assertion errors, can provide a detailed error messages.\n *\n * inspect() and cliMessage() added to display errors with params.\n */\nfunction AssertionFailedError(params, template) {\n  this.params = params;\n  this.template = template;\n  // this.message = \"AssertionFailedError\";\n  let stack = new Error().stack;\n  // this.showDiff = true;\n  stack = stack.split(\"\\n\").filter((line) => {\n    // @todo cut assert things nicer\n    return line.indexOf('lib/assert') < 0;\n  });\n  this.stack = stack.join(\"\\n\");\n  this.showDiff = true;\n\n  this.actual = this.params.actual;\n  this.expected = this.params.expected;\n\n  this.inspect = () => {\n    let params = this.params || {};\n    let msg = params.customMessage || '';\n    return msg + subs(this.template, params);\n  };\n\n  this.cliMessage = () => {\n    return this.inspect();\n  };\n}\n\nAssertionFailedError.prototype = Object.create(Error.prototype);\n\nmodule.exports = AssertionFailedError;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/config.js":"'use strict';\nlet fs = require('fs');\nlet path = require('path');\nlet isFile = require('./utils').isFile;\nlet fileExists = require('./utils').fileExists;\nconst deepMerge = require('./utils').deepMerge;\n\nlet defaultConfig = {\n  output: './_output',\n  helpers: {},\n  include: {},\n  mocha: {},\n  bootstrap: null,\n  teardown: null,\n  hooks: []\n};\n\nlet config = {};\n\n/**\n * Current configuration\n */\nclass Config {\n\n  /**\n   * Create a config with default options\n   *\n   * @param {*} newConfig\n   */\n  static create(newConfig) {\n    return config = deepMerge(defaultConfig, newConfig);\n  }\n\n  /**\n   * Load config from a file.\n   * If js file provided: require it and get .config key\n   * If json file provided: load and parse JSON\n   * If directory provided:\n   * * try to load `codecept.conf.js` from it\n   * * try to load `codecept.json` from it\n   * If none of above: fail.\n   *\n   * @param {*} configFile\n   */\n  static load(configFile) {\n    configFile = path.resolve(configFile || '.');\n\n\n    if (!fileExists(configFile)) {\n      throw new Error(`Config file ${configFile} does not exist. Execute 'codeceptjs init' to create config`);\n    }\n\n    // is config file\n    if (isFile(configFile)) {\n      return loadConfigFile(configFile);\n    }\n\n    // is path to directory\n    let jsConfig = path.join(configFile, 'codecept.conf.js');\n    if (isFile(jsConfig)) {\n      return loadConfigFile(jsConfig);\n    }\n\n    let jsonConfig = path.join(configFile, 'codecept.json');\n    if (isFile(jsonConfig)) {\n      return loadConfigFile(jsonConfig);\n    }\n\n    throw new Error(`Can not load config from ${jsConfig} or ${jsonConfig}\\nCodeceptJS is not initialized in this dir. Execute 'codeceptjs init' to start`);\n  }\n\n  /**\n   * Get current config.\n   */\n  static get() {\n    return config;\n  }\n\n  /**\n   * Appends values to current config\n   *\n   * @param {*} additionalConfig\n   */\n  static append(additionalConfig) {\n    return config = deepMerge(config, additionalConfig);\n  }\n\n  /**\n   * Resets config to default\n   */\n  static reset() {\n    return config = defaultConfig;\n  }\n}\n\nmodule.exports = Config;\n\nfunction loadConfigFile(configFile) {\n  // .conf.js config file\n  if (path.extname(configFile) == '.js') {\n    return Config.create(require(configFile).config);\n  }\n\n  // json config provided\n  if (path.extname(configFile) == '.json') {\n    return Config.create(JSON.parse(fs.readFileSync(configFile, 'utf8')));\n  }\n  throw new Error(`Config file ${configFile} can't be loaded`);\n}\n\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/hooks.js":"'use strict';\n\nlet getParamNames = require('./utils').getParamNames;\nlet fsPath = require('path');\nlet fileExists = require('./utils').fileExists;\n\nmodule.exports = function (hook, done, stage) {\n  stage = stage || 'bootstrap';\n  if (typeof hook === 'string' && fileExists(fsPath.join(codecept_dir, hook))) {\n    var callable = require(fsPath.join(codecept_dir, hook));\n    if (typeof callable === 'function') {\n      callSync(callable, done);\n      return;\n    }\n    if (typeof callable === 'object' && callable[stage]) {\n      callSync(callable[stage], done);\n      return;\n    }\n  } else if (typeof hook === 'function') {\n    callSync(hook, done);\n    return;\n  }\n  // if async - call done\n  if (done) done();\n};\n\nfunction callSync(callable, done) {\n  if (isAsync(callable)) {\n    callable(done);\n  } else {\n    callable();\n    if (done) done();\n  }\n}\n\nfunction isAsync(fn) {\n  let params = getParamNames(fn);\n  return params && params.length;\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/recorder.js":"'use strict';\n\nlet promise, oldPromise;\nlet running = false;\nlet errFn;\nlet next;\nlet queueId = 0;\nlet sessionId = null;\n\nlet log = require('./output').log;\nlet tasks = [];\n\n/**\n * Singleton object to record all test steps as promises and run them in chain.\n */\nmodule.exports = {\n\n  /**\n   * Start recording promises\n   *\n   * @api\n   */\n  start() {\n    running = true;\n    errFn = null;\n    this.reset();\n  },\n\n  /**\n   * Add error handler to catch rejected promises\n   *\n   * @api\n   * @param {*} fn\n   */\n  errHandler(fn) {\n    errFn = fn;\n  },\n\n  /**\n   * Stops current promise chain, calls `catch`.\n   * Resets recorder to initial state.\n   *\n   * @api\n   */\n  reset() {\n    if (promise && running) this.catch();\n    queueId++;\n    sessionId = null;\n    log(currentQueue() + `Starting recording promises`);\n    promise = Promise.resolve();\n    oldPromise = null;\n    tasks = [];\n    this.session.running = false;\n  },\n\n  session: {\n    running: false,\n\n    start(name) {\n      log(currentQueue() + `Starting <${name}> session`);\n      tasks.push('--->');\n      oldPromise = promise;\n      this.running = true;\n      sessionId = name;\n      promise = Promise.resolve();\n    },\n\n    restore() {\n      tasks.push('<---');\n      log(currentQueue() + `Starting <${this.name}> session`);\n      this.running = false;\n      sessionId = null;\n      promise = promise.then(() => oldPromise);\n    },\n\n    catch(errFn) {\n      promise = promise.catch(errFn);\n    }\n\n  },\n\n  /**\n   * Adds a promise to a chain.\n   * Promise description should be passed as first parameter.\n   *\n   * @param {*} taskName\n   * @param {*} fn\n   * @param {*} force\n   */\n  add(taskName, fn, force) {\n    if (typeof taskName === \"function\") {\n      fn = taskName;\n      taskName = fn.toString();\n    }\n    if (!running && !force) {\n      return;\n    }\n    tasks.push(taskName);\n    log(currentQueue() + `Queued | ${taskName}`);\n    return promise = promise.then(fn);\n  },\n\n  catch(customErrFn) {\n    return promise = promise.catch((err) => {\n      log(currentQueue() + `Error | ${err}`);\n      if (!(err instanceof Error)) { // strange things may happen\n        err = new Error('[Wrapped Error] ' + JSON.stringify(err)); // we should be prepared for them\n      }\n      if (customErrFn) {\n        customErrFn(err);\n      } else if (errFn) {\n        errFn(err);\n      }\n      this.stop();\n    });\n  },\n\n  /**\n   * Adds a promise which throws an error into a chain\n   *\n   * @api\n   * @param {*} err\n   */\n  throw(err) {\n    return this.add('throw error ' + err, function () {\n      throw err;\n    });\n  },\n\n  /**\n   * Stops recording promises\n   * @api\n   */\n  stop() {\n    log(currentQueue() + `Stopping recording promises`);\n    var err = new Error();\n    running = false;\n  },\n\n  /**\n   * Get latest promise in chain.\n   *\n   * @api\n   */\n  promise() {\n    return promise;\n  },\n\n  /**\n   * Get a list of all chained tasks\n   */\n  scheduled() {\n    return tasks.join(\"\\n\");\n  },\n\n  /**\n   * Get a state of current queue and tasks\n   */\n  toString() {\n    return `Queue: ${currentQueue()}\\n\\nTasks: ${this.scheduled()}`;\n  }\n\n};\n\nfunction currentQueue() {\n  let session = '';\n  if (sessionId) session = `<${sessionId}> `;\n  return `[${queueId}] ${session}`;\n}\n\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/actor.js":"'use strict';\nlet Step = require('./step');\nlet container = require('./container');\nlet methodsOfObject = require('./utils').methodsOfObject;\nlet recorder = require('./recorder');\nlet event = require('./event');\nlet output = require('./output');\n\n/**\n * Fetches all methods from all enabled helpers,\n * and makes them available to use from I. object\n * Wraps helper methods into promises.\n */\nmodule.exports = function (obj) {\n  obj = obj || {};\n\n  let helpers = container.helpers();\n\n  // add methods from enabled helpers\n  Object.keys(helpers)\n    .map((key) => helpers[key])\n    .forEach((helper) => {\n      methodsOfObject(helper, 'Helper')\n      .filter((method) => {\n        return method !== 'constructor' && method[0] !== '_';\n      })\n      .forEach((action) => {\n        let actionAlias = container.translation().actionAliasFor(action);\n\n        obj[action] = obj[actionAlias] = function () {\n          let step = new Step(helper, action);\n          if (container.translation().loaded) {\n            step.name = actionAlias;\n            step.actor = container.translation().I;\n          }\n          // add methods to promise chain\n          return recordStep(step, Array.prototype.slice.call(arguments));\n        };\n      });\n    });\n\n  // add print comment method`\n  obj.say = (msg) => recorder.add(`say ${msg}`, () => output.say(msg));\n\n  return obj;\n};\n\nfunction recordStep(step, args) {\n  step.status = 'queued';\n  step.setArguments(args);\n\n  // run async before step hooks\n  event.emit(event.step.before, step);\n\n  let task = `${step.name}: ${step.humanizeArgs()}`;\n  let val;\n\n  // run step inside promise\n  recorder.add(task, () => {\n    event.emit(event.step.started, step);\n    val = step.run.apply(step, args);\n  });\n\n  // run async after step hooks\n  event.emit(event.step.after, step);\n\n  // ensure step result is passed to next step\n  recorder.add('return step result', () => val);\n  return recorder.promise();\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/step.js":"'use strict';\n\n/**\n * Each command in test executed through `I.` object is wrapped in Step.\n * Step allows logging executed commands and triggers hook before and after step execution.\n */\nclass Step {\n\n  constructor(helper, name) {\n    this.actor = 'I'; // I = actor\n    this.helper = helper; // corresponding helper\n    this.name = name; // name of a step console\n    this.helperMethod = name; // helper method\n    this.status = 'pending';\n    this.prefix = this.suffix = '';\n    Error.captureStackTrace(this);\n    this.args = [];\n  }\n\n  setArguments(args) {\n    this.args = args;\n  }\n\n  run() {\n    this.args = Array.prototype.slice.call(arguments);\n    let result;\n    try {\n      result = this.helper[this.helperMethod].apply(this.helper, this.args);\n      this.status = 'success';\n    } catch (err) {\n      this.status = 'failed';\n      throw err;\n    }\n    return result;\n  }\n\n  humanize() {\n    return this.name\n    // insert a space before all caps\n    .replace(/([A-Z])/g, ' $1')\n    // _ chars to spaces\n    .replace('_', ' ')\n    // uppercase the first character\n    .replace(/^(.)|\\s(.)/g, function ($1) {\n      return $1.toLowerCase();\n    });\n  }\n\n  humanizeArgs() {\n    return this.args.map((arg) => {\n      if (typeof arg === \"string\") {\n        return `\"${arg}\"`;\n      } else if (Array.isArray(arg)) {\n        return `[${arg.toString()}]`;\n      } else if (typeof arg === \"function\") {\n        return \"function()\";\n      } else if (typeof arg === \"object\") {\n        return JSON.stringify(arg);\n      } else if (arg.toString) {\n        return arg.toString();\n      }\n      return arg;\n    }).join(', ');\n  }\n\n  line() {\n    var lines = this.stack.split('\\n');\n    // 3rd line is line where step has been called in test\n    if (lines[3]) return lines[3].trim();\n    return '';\n  }\n\n  toString() {\n    return `${this.prefix}${this.actor} ${this.humanize()} ${this.humanizeArgs()}${this.suffix}`;\n  }\n\n  toCode() {\n    return `${this.prefix}${this.actor}.${this.name}(${this.humanizeArgs()})${this.suffix}`;\n  }\n\n}\n\nmodule.exports = Step;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper.js":"'use strict';\n\nlet container = require('./container');\nlet debug = require('./output').debug;\n\n/**\n * @inner\n * Abstract class.\n * Helpers abstracts test execution backends.\n *\n * Methods of Helper class will be available in tests in `I` object.\n * They provide user-friendly abstracted actions over NodeJS libraries.\n *\n * Hooks (methods starting with `_`) can be used to setup/teardown,\n * or handle execution flow.\n *\n * Methods are expected to return a value in order to be wrapped in promise.\n */\nclass Helper {\n\n  constructor(config) {\n    this.config = config;\n  }\n\n  /**\n   * Abstract method to provide requried config options\n   */\n  static _config() {\n\n  }\n\n  /**\n   * Hook executed before all tests\n   */\n  _init() {\n\n  }\n\n  /**\n   * Hook executed before each test.\n   */\n  _before() {\n\n  }\n\n  /**\n   * Hook executed after each test\n   */\n  _after() {\n\n  }\n\n  /**\n   * Hook provides a test details\n   * Executed in the very beginning of a test\n   *\n   * @param test\n   */\n  _test() {\n\n  }\n\n  /**\n   * Hook executed after each failed test\n   *\n   * @param test\n   */\n  _failed() {\n\n  }\n\n  /**\n   * Hook executed before each step\n   *\n   * @param step\n   * @override\n   *\n   * _beforeStep()\n   */\n\n  /**\n   * Hook executed after each step\n   *\n   * @param step\n   * @override\n   *\n   * _afterStep()\n   */\n\n  /**\n   * Hook executed before each suite\n   *\n   * @param suite\n   */\n  _beforeSuite() {\n\n  }\n\n  /**\n   * Hook executed after each suite\n   *\n   * @param suite\n   */\n  _afterSuite() {\n\n  }\n\n  /**\n   * Access another configured helper: `this.helpers['AnotherHelper']`\n   */\n  get helpers() {\n    return container.helpers();\n  }\n\n  /**\n   * Print debug message to console (outputs only in debug mode)\n   */\n  debug(msg) {\n    debug(msg);\n  }\n\n  debugSection(section, msg) {\n    debug(`[${section}] ${msg}`);\n  }\n\n}\n\nmodule.exports = Helper;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/pause.js":"'use strict';\n\nlet container = require('./container');\nlet recorder = require('./recorder');\nlet output = require('./output');\nlet methodsOfObject = require('./utils').methodsOfObject;\n\nlet readline = require('readline');\nlet util = require('util');\nlet colors = require('chalk'); // npm install colors\nlet rl, nextStep, finish;\n\n/**\n * Pauses test execution and starts interactive shell\n */\nmodule.exports = function () {\n  recorder.add('Start new session', function () {\n    recorder.session.start('pause');\n    output.print(colors.yellow(\" Interative debug session started\"));\n    output.print(colors.yellow(\" Use JavaScript syntax to try steps in action\"));\n    output.print(colors.yellow(` Press ${colors.bold('ENTER')} to continue`));\n    rl = readline.createInterface(process.stdin, process.stdout, completer);\n\n    rl.on('line', parseInput);\n    rl.on('close', function () {\n      console.log('Exiting interactive shell....');\n    });\n    return new Promise(function (resolve) {\n      finish = resolve;\n      return askForStep();\n    });\n  });\n};\n\nfunction parseInput(cmd) {\n  rl.pause();\n  if (!cmd) {\n    finish();\n    recorder.session.restore();\n    rl.close();\n    return nextStep();\n  }\n  try {\n    let I = container.support('I');\n    eval('I.' + cmd);\n  } catch (err) {\n    output.print(output.styles.error(\" ERROR \"), err.message);\n  }\n  recorder.session.catch(function (err) {\n    let msg = err.cliMessage ? err.cliMessage() : err.message;\n    return output.print(output.styles.error(\" FAIL \"), msg);\n  });\n  recorder.add('ask for next step', askForStep);\n  nextStep();\n}\n\nfunction askForStep() {\n  return new Promise(function (resolve) {\n    nextStep = resolve;\n    rl.setPrompt(' I.', 3);\n    rl.resume();\n    rl.prompt();\n  });\n}\n\nfunction completer(line) {\n  let I = container.support('I');\n  var completions = methodsOfObject(I);\n  var hits = completions.filter(function (c) {\n    if (c.indexOf(line) === 0) {\n      // console.log('bang! ' + c);\n      return c;\n    }\n  });\n  return [hits && hits.length ? hits : completions, line];\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/within.js":"'use strict';\nlet output = require('./output');\nlet recorder = require('./recorder');\nlet container = require('./container');\nlet event = require('./event');\n\nfunction within(context, fn) {\n  recorder.add('register within wrapper', function () {\n\n    recorder.session.start('within');\n    let helpers = container.helpers();\n    let locator = typeof context === 'object' ? JSON.stringify(context) : context;\n    let addContextToStep = function (step) {\n      step.prefix = `Within ${locator}: `;\n    };\n\n    event.dispatcher.on(event.step.after, addContextToStep);\n    output.stepShift = 2;\n    if (output.level() > 0) output.print(`   Within ${output.colors.yellow.bold(locator)}:`);\n    Object.keys(helpers).forEach((helper) => {\n      if (helpers[helper]._withinBegin) recorder.add('start within block', () => helpers[helper]._withinBegin(context));\n    });\n\n    fn();\n\n    Object.keys(helpers).forEach((helper) => {\n      if (helpers[helper]._withinEnd) recorder.add('finish within block', () => helpers[helper]._withinEnd());\n    });\n\n    recorder.add('restore session', () => {\n      recorder.session.restore();\n      output.stepShift = 1;\n      event.dispatcher.removeListener(event.step.after, addContextToStep);\n    });\n    return recorder.promise();\n  });\n}\n\nmodule.exports = within;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/bin/codecept.js":"#!/usr/bin/env node\n'use strict';\n\nvar program = require('commander');\nvar path = require('path');\nvar Config = require('../lib/config');\nvar Codecept = require('../lib/codecept');\nvar print = require('../lib/output');\nvar fileExists = require('../lib/utils').fileExists;\nvar fs = require('fs');\n\nprogram.command('init [path]')\n  .description('Creates dummy config in current dir or [path]')\n  .action(require('../lib/command/init'));\n\nprogram.command('shell [path]')\n  .alias('sh')\n  .description('Interative shell')\n  .option('--verbose', 'output internal logging information')\n  .option('--profile [value]', 'configuration profile to be used')\n  .action(require('../lib/command/interactive'));\n\nprogram.command('list [path]')\n  .alias('l')\n  .description('List all actions for I.')\n  .action(require('../lib/command/list'));\n\nprogram.command('def [path]')\n  .description('List all actions for I.')\n  .action(require('../lib/command/definitions'));\n\nprogram.command('generate:test [path]')\n  .alias('gt')\n  .description('Generates an empty test')\n  .action(require('../lib/command/generate').test);\n\nprogram.command('generate:pageobject [path]')\n  .alias('gpo')\n  .description('Generates an empty page object')\n  .action(require('../lib/command/generate').pageObject);\n\nprogram.command('generate:object [path]')\n  .alias('go')\n  .option('--type, -t [kind]', 'type of object to be created')\n  .description('Generates an empty support object (page/step/fragment)')\n  .action(require('../lib/command/generate').pageObject);\n\nprogram.command('generate:helper [path]')\n  .alias('gh')\n  .description('Generates a new helper')\n  .action(require('../lib/command/generate').helper);\n\nprogram.command('run [test]')\n  .description('Executes tests')\n\n  // codecept-only options\n  .option('--steps', 'show step-by-step execution')\n  .option('--debug', 'output additional information')\n  .option('--verbose', 'output internal logging information')\n  .option('-o, --override [value]', 'override current config options')\n  .option('--profile [value]', 'configuration profile to be used')\n  .option('-c, --config [file]', 'configuration file to be used')\n\n  // mocha options\n  .option('--colors', 'force enabling of colors')\n  .option('--no-colors', 'force disabling of colors')\n  .option('-G, --growl', 'enable growl notification support')\n  .option('-O, --reporter-options <k=v,k2=v2,...>', 'reporter-specific options')\n  .option('-R, --reporter <name>', 'specify the reporter to use')\n  .option('-S, --sort', \"sort test files\")\n  .option('-b, --bail', \"bail after first test failure\")\n  .option('-d, --debug', \"enable node's debugger, synonym for node --debug\")\n  .option('-g, --grep <pattern>', 'only run tests matching <pattern>')\n  .option('-f, --fgrep <string>', 'only run tests containing <string>')\n  .option('-i, --invert', 'inverts --grep and --fgrep matches')\n  .option('--full-trace', 'display the full stack trace')\n  .option('--compilers <ext>:<module>,...', 'use the given module(s) to compile files')\n  .option('--debug-brk', \"enable node's debugger breaking on the first line\")\n  .option('--inline-diffs', 'display actual/expected differences inline within each string')\n  .option('--no-exit', 'require a clean shutdown of the event loop: mocha will not call process.exit')\n  .option('--recursive', 'include sub directories')\n  .option('--trace', 'trace function calls')\n  .option('--child <string>', 'option for child processes')\n\n  .action(require('../lib/command/run'));\n\nprogram.command('run-multiple [suites...]')\n  .description('Executes tests multiple')\n  .option('-c, --config [file]', 'configuration file to be used')\n  .option('--all', 'run all suites')\n  .option('-g, --grep <pattern>', 'only run tests matching <pattern>')\n  .option('-f, --fgrep <string>', 'only run tests containing <string>')\n  .option('--steps', 'show step-by-step execution')\n  .option('--verbose', 'output internal logging information')\n  .option('-o, --override [value]', 'override current config options')\n  .option('-O, --reporter-options <k=v,k2=v2,...>', 'reporter-specific options')\n  .option('-R, --reporter <name>', 'specify the reporter to use')\n  .option('--recursive', 'include sub directories')\n\n  .action(require('../lib/command/run-multiple'));\n\nif (process.argv.length <= 2) {\n  console.log('CodeceptJS v' + Codecept.version());\n  program.outputHelp();\n}\nprogram.parse(process.argv);\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/init.js":"'use strict';\nlet print = require('../output').print;\nlet success = require('../output').success;\nlet error = require('../output').error;\nlet colors = require('chalk');\nlet fs = require('fs');\nlet path = require('path');\nlet fileExists = require('../utils').fileExists;\nlet inquirer = require(\"inquirer\");\nlet getTestRoot = require(\"./utils\").getTestRoot;\nlet isLocal = require('../utils').installedLocally();\nlet mkdirp = require('mkdirp');\n\nlet defaultConfig = {\n  tests: \"./*_test.js\",\n  timeout: 10000,\n  output: null,\n  helpers: {},\n  include: {},\n  bootstrap: false,\n  mocha: {}\n};\n\nlet helpers = ['WebDriverIO', 'Protractor', 'SeleniumWebdriver', 'Nightmare', 'FileSystem'];\nlet translations = Object.keys(require('../../translations'));\nlet noTranslation = 'English (no localization)';\ntranslations.unshift(noTranslation);\n\nlet packages;\n\nlet defaultActor = `\n'use strict';\n// in this file you can append custom step methods to 'I' object\n\nmodule.exports = function() {\n  return actor({\n\n    // Define custom steps here, use 'this' to access default methods of I.\n    // It is recommended to place a general 'login' function here.\n\n  });\n}\n`;\n\n\nmodule.exports = function (initPath) {\n  let testsPath = getTestRoot(initPath);\n\n  print();\n  print(`  Welcome to ${colors.magenta.bold('CodeceptJS')} initialization tool`);\n  print(\"  It will prepare and configure a test environment for you\");\n  print();\n\n\n  if (!path) {\n    print(`No test root specified.`);\n    print(`Test root is assumed to be ${colors.yellow.bold(testsPath)}`);\n    print('----------------------------------');\n  } else {\n    print(`Installing to ${colors.bold(testsPath)}`);\n  }\n\n  if (!fileExists(testsPath)) {\n    print(`Directory ${testsPath} does not exist, creating...`);\n    mkdirp.sync(testsPath);\n  }\n\n  let configFile = path.join(testsPath, 'codecept.json');\n  if (fileExists(configFile)) {\n    error(`Config is already created at ${configFile}`);\n    return;\n  }\n\n\n  inquirer.prompt(\n    [\n      {\n        name: \"tests\",\n        type: \"input\",\n        default: \"./*_test.js\",\n        message: \"Where are your tests located?\"\n      },\n      {\n        name: \"helpers\",\n        type: \"checkbox\",\n        choices: helpers,\n        message: \"What helpers do you want to use?\"\n      },\n      {\n        name: \"output\",\n        default: \"./output\",\n        message: \"Where should logs, screenshots, and reports to be stored?\"\n      },\n      {\n        name: \"steps\",\n        type: \"confirm\",\n        message: \"Would you like to extend I object with custom steps?\",\n        default: true\n      },\n      {\n        name: \"translation\",\n        type: \"list\",\n        message: \"Do you want to choose localization for tests?\",\n        choices: translations\n      },\n      {\n        name: \"steps_file\",\n        type: \"input\",\n        message: \"Where would you like to place custom steps?\",\n        default: \"./steps_file.js\",\n        when: function (answers) {\n          return answers.steps;\n        }\n      }\n    ], (result) => {\n    let config = defaultConfig;\n    config.name = testsPath.split(path.sep).pop();\n    config.output = result.output;\n\n    config.tests = result.tests;\n    // create a directory tests it is included in tests path\n    mkdirp.sync(path.join(testsPath, config.tests.match(/[^*.]+/)[0]));\n\n    // append file mask to the end of tests\n    if (!config.tests.match(/\\*(.*?)$/)) {\n      config.tests = config.tests.replace(/\\/+$/, '') + \"/*_test.js\";\n      console.log(`Adding default test mask: ${config.tests}`);\n    }\n\n    if (result.translation !== noTranslation) config.translation = result.translation;\n\n    result.helpers.forEach((helper) => config.helpers[helper] = {});\n\n    let helperConfigs = [];\n\n    result.helpers.forEach((helperName) => {\n      try {\n        let Helper = require('../helper/' + helperName);\n        if (Helper._checkRequirements) {\n          packages = Helper._checkRequirements();\n        }\n\n        if (!Helper._config()) return;\n        helperConfigs = helperConfigs.concat(Helper._config().map((config) => {\n          config.message = `[${helperName}] ${config.message}`;\n          config.name = `${helperName}_${config.name}`;\n          config.type = config.type || 'input';\n          return config;\n        }));\n      } catch (err) {\n        error(err);\n      }\n    });\n\n    let finish = () => {\n      if (result.steps_file) {\n        let stepFile = path.join(testsPath, result.steps_file);\n        if (!fileExists(path.dirname(stepFile))) {\n          mkdirp.sync(path.dirname(stepFile));\n        }\n        fs.writeFileSync(stepFile, defaultActor);\n        config.include.I = result.steps_file;\n        success('Steps file created at ' + stepFile);\n      }\n\n      fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\n      success(`Config created at ${configFile}`);\n\n      if (config.output) {\n        if (!fileExists(config.output)) {\n          mkdirp.sync(path.join(testsPath, config.output));\n          success(\"Directory for temporary output files created at `_output`\");\n        } else {\n          print(`Directory for temporary output files is already created at '${config.output}'`);\n        }\n      }\n      success(\"Almost done! Create your first test by executing `codeceptjs gt` (generate test) command\");\n\n      if (packages) {\n        print(\"\\n--\");\n        if (isLocal) {\n          print(\"Please install dependent packages locally: \" + colors.bold('npm install --save-dev ' + packages.join(' ')));\n        } else {\n          print(\"Please install dependent packages globally: [sudo] \" + colors.bold('npm install -g ' + packages.join(' ')));\n        }\n      }\n    };\n\n    if (!result.helpers.length) {\n      return finish();\n    }\n\n    print(\"Configure helpers...\");\n    inquirer.prompt(helperConfigs, (helperResult) => {\n\n      Object.keys(helperResult).forEach((key) => {\n        let helperName, configName;\n        let parts = key.split('_');\n        helperName = parts[0];\n        configName = parts[1];\n        if (!configName) return;\n        config.helpers[helperName][configName] = helperResult[key];\n      });\n\n      finish();\n    });\n\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/utils.js":"'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst output = require('../output');\n\n// alias to deep merge\nmodule.exports.deepMerge = require('../utils').deepMerge;\nmodule.exports.getConfig = function (configFile) {\n  try {\n    return require('../config').load(configFile);\n  } catch (err) {\n    fail(err.message);\n  }\n};\n\nfunction getTestRoot(currentPath) {\n  if (!currentPath) currentPath = '.';\n  if (!path.isAbsolute(currentPath)) currentPath = path.join(process.cwd(), currentPath);\n  return currentPath = !path.extname(currentPath) ? currentPath : path.dirname(currentPath);\n}\nmodule.exports.getTestRoot = getTestRoot;\n\nfunction fail(msg) {\n  output.error(msg);\n  process.exit(1);\n}\n\nmodule.exports.fail = fail;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/translations/index.js":"exports['pt-BR'] = require('./pt-BR');\nexports['ru-RU'] = require('./ru-RU');\nexports['it-IT'] = require('./it-IT');\nexports['pl-PL'] = require('./pl-PL');","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/translations/pt-BR.js":"\n\nmodule.exports = {\n    I: 'Eu',\n    actions: {\n        'amOutsideAngularApp': 'naoEstouEmAplicacaoAngular',\n        'amInsideAngularApp': 'estouNaAplicacaoAngular',\n        'waitForElement': 'aguardoPeloElemento',\n        'waitForClickable': 'aguardoPorClicavel',\n        'waitForVisible': 'aguardoPorVisivel',\n        'waitForText': 'aguardoPorTexto',\n        'moveTo': 'movoPara',\n        'refresh': 'atualizoAPagina',\n        'haveModule': 'temModulo',\n        'resetModule': 'resetoModulo',\n        'amOnPage': 'estouNaPagina',\n        'click': 'clico',\n        'doubleClick': 'clicoDuplamente',\n        'see': 'vejo',\n        'dontSee': 'naoVejo',\n        'selectOption': 'selecionoAOpcao',\n        'fillField': 'preenchoOCampo',\n        'pressKey': 'pressioneATecla',\n        'attachFile': 'anexaOArquivo',\n        'seeInField': 'vejoNoCampo',\n        'dontSeeInField': 'naoVejoNoCampo',\n        'appendField': 'adicionaCampo',\n        'checkOption': 'marcoOpcao',\n        'seeCheckboxIsChecked': 'vejoCheckboxMarcado',\n        'dontSeeCheckboxIsChecked': 'naoVejoCheckboxMarcado',\n        'grabTextFrom': 'pegoTextoDe',\n        'grabValueFrom': 'pegoValorDe',\n        'grabAttributeFrom': 'pegoAtributoDe',\n        'seeInTitle': 'VejoNoTitulo',\n        'dontSeeInTitle': 'naoVejoNoTitulo',\n        'grabTitle': 'pegoOTitulo',\n        'seeElement': 'vejoElemento',\n        'dontSeeElement': 'naoVejoElemento',\n        'seeInSource': 'vejoNoCodigo',\n        'dontSeeInSource': 'naoVejoNoCodigo',\n        'executeScript': 'executoScript',\n        'executeAsyncScript': 'executoScriptAssincrono',\n        'seeInCurrentUrl': 'vejoNaUrl',\n        'dontSeeInCurrentUrl': 'naoVejoNaUrl',\n        'seeCurrentUrlEquals': 'vejoUrlIgualA',\n        'dontSeeCurrentUrlEquals': 'naoVejoUrlIgualA',\n        'saveScreenshot': 'salvoCapturaDeTela',\n        'setCookie': 'definoCookie',\n        'clearCookie': 'limpoCookies',\n        'seeCookie': 'vejoCookie',\n        'dontSeeCookie': 'naoVejoCookie',\n        'grabCookie': 'pegoCookie',\n        'resizeWindow': 'redimensionaJanela',\n        'wait': 'aguardo'\n    }\n}","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/translations/ru-RU.js":"module.exports = {\n    I: 'Я',\n    actions: {\n        'waitForElement': 'ожидаю_элемент',\n        'waitForVisible': 'ожидаю_увидеть',\n        'waitForText': 'ожидаю_текст',\n        'amOnPage': 'на_странице',\n        'click': 'кликаю',\n        'doubleClick': 'дважды_кликаю',\n        'see': 'вижу',\n        'dontSee': 'не_вижу',\n        'selectOption': 'выбираю_опцию',\n        'fillField': 'заполнаю_поле',\n        'pressKey': 'нажимаю_кнопку',\n        'attachFile': 'загружаю_файл',\n        'seeInField': 'вижу_в_поле',\n        'dontSeeInField': 'не_вижу_в_поле',\n        'appendField': 'дописываю_в_поле',\n        'checkOption': 'выбираю_опцию',\n        'seeCheckboxIsChecked': 'вижу_галочку',\n        'dontSeeCheckboxIsChecked': 'не_вижу_галочку',\n        'grabTextFrom': 'беру_текст_из',\n        'grabValueFrom': 'беру_значение_из',\n        'grabAttributeFrom': 'беру_атрибут_из',\n        'seeInTitle': 'вижу_в_заголовке',\n        'dontSeeInTitle': 'не_вижу_в_заголовке',\n        'grabTitle': 'беру_заголовок',\n        'seeElement': 'вижу_элемент',\n        'dontSeeElement': 'не_вижу_элемент',\n        'seeInSource': 'вижу_в_коде',\n        'dontSeeInSource': 'не_вижу_в_коде',\n        'executeScript': 'выполняю_скрипт',\n        'executeAsyncScript': 'выполняю_скрипт_асинхронно',\n        'seeInCurrentUrl': 'вижу_в_адресе',\n        'dontSeeInCurrentUrl': 'не_вижу_в_адресе',\n        'seeCurrentUrlEquals': 'вижу_адрес_равен',\n        'dontSeeCurrentUrlEquals': 'не_вижу_адрес',\n        'saveScreenshot': 'делаю_скриншот',\n        'setCookie': 'устанавливаю_куки',\n        'clearCookie': 'очищаю_куки',\n        'seeCookie': 'вижу_в_куки',\n        'dontSeeCookie': 'не_вижу_в_куки',\n        'grabCookie': 'беру_куки',\n        'resizeWindow': 'растягиваю_окно',\n        'wait': 'жду'\n    }\n}","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/translations/it-IT.js":"module.exports = {\n    I: 'io',\n    actions: {\n        'amOutsideAngularApp': 'sono_fuori_dalla_applicazione_angular',\n        'amInsideAngularApp': 'sono_dentro_la_applicazione_angular',\n        'waitForElement': 'aspetto_lo_elemento',\n        'waitForClickable': 'aspetto_che_sia_cliccabile',\n        'waitForVisible': 'aspetto_che_sia_visibile',\n        'waitForText': 'aspetto_il_testo',\n        'moveTo': 'mi_muovo_su',\n        'refresh': 'aggiorno',\n        'haveModule': 'ho_il_modulo',\n        'resetModule': 'ripristino_il_modulo',\n        'amOnPage': 'sono_sulla_pagina',\n        'click': 'faccio_click_su',\n        'doubleClick': 'faccio_doppio_click_su',\n        'see': 'vedo',\n        'dontSee': 'non_vedo',\n        'selectOption': 'seleziono_la_opzione',\n        'fillField': 'compilo_il_campo',\n        'pressKey': 'premo_il_tasto',\n        'attachFile': 'allego_il_file',\n        'seeInField': 'vedo_nel_campo',\n        'dontSeeInField': 'non_vedo_nel_campo',\n        'appendField': 'aggiungo_il_campo',\n        'checkOption': 'spunto_la_opzione',\n        'seeCheckboxIsChecked': 'vedo_la_checkbox_spuntata',\n        'dontSeeCheckboxIsChecked': 'non_vedo_la_checkbox_spuntata',\n        'grabTextFrom': 'prendo_il_testo_da',\n        'grabValueFrom': 'prendo_il_valore_da',\n        'grabAttributeFrom': 'prendo_lo_attributo_da',\n        'seeInTitle': 'vedo_nel_titolo',\n        'dontSeeInTitle': 'non_vedo_nel_titolo',\n        'grabTitle': 'prendo_il_titolo',\n        'seeElement': 'vedo_lo_elemento',\n        'dontSeeElement': 'non_vedo_lo_elemento',\n        'seeInSource': 'vedo_nel_sorgente',\n        'dontSeeInSource': 'non_vedo_nel_sorgente',\n        'executeScript': 'eseguo_lo_script',\n        'executeAsyncScript': 'eseguo_lo_script_asincrono',\n        'seeInCurrentUrl': 'vedo_nella_url',\n        'dontSeeInCurrentUrl': 'non_vedo_nella_url',\n        'seeCurrentUrlEquals': 'la_url_e_uguale_a',\n        'dontSeeCurrentUrlEquals': 'la_url_non_e_uguale_a',\n        'saveScreenshot': 'salvo_la_schermata',\n        'setCookie': 'imposto_il_cookie',\n        'clearCookie': 'rimuovo_il_cookie',\n        'seeCookie': 'vedo_il_cookie',\n        'dontSeeCookie': 'non_vedo_il_cookie',\n        'grabCookie': 'prendo_il_cookie',\n        'resizeWindow': 'ridimesiono_la_finestra',\n        'wait': 'aspetto'\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/translations/pl-PL.js":"module.exports = {\n    I: 'Ja',\n    actions: {\n        'amOutsideAngularApp': 'jestem_poza_aplikacją_angular',\n        'amInsideAngularApp': 'jestem_w_aplikacji_angular',\n        'waitForElement': 'czekam_na_element',\n        'waitForClickable': 'czekam_aż_będzie_klikalny',\n        'waitForVisible': 'czekam_aż_będzie_widoczny',\n        'waitForText': 'czekam_na_tekst',\n        'moveTo': 'przesuwam_do',\n        'refresh': 'odświeżam',\n        'haveModule': 'ma_moduł',\n        'resetModule': 'resetuję_moduł',\n        'amOnPage': 'jestem_na_stronie',\n        'click': 'klikam',\n        'doubleClick': 'podwójnie_klikam',\n        'see': 'widzę',\n        'dontSee': 'nie_widzę',\n        'selectOption': 'wybieram_opcję',\n        'fillField': 'wypełniam_pole',\n        'pressKey': 'naciskam_przycisk',\n        'attachFile': 'załączam_plik',\n        'seeInField': 'widzę_w_polu',\n        'dontSeeInField': 'nie_widzę_w_polu',\n        'appendField': 'dostawiam_pole',\n        'checkOption': 'zaznaczam_opcję',\n        'seeCheckboxIsChecked': 'widzę_zaznaczony_checkbox',\n        'dontSeeCheckboxIsChecked': 'nie_widzę_zaznaczonego_checkboxu',\n        'grabTextFrom': 'pobieram_text_z',\n        'grabValueFrom': 'pobieram_wartość_z',\n        'grabAttributeFrom': 'pobieram_atrybut_z',\n        'seeInTitle': 'widzę_w_tytule',\n        'dontSeeInTitle': 'nie_widzę_w_tytule',\n        'grabTitle': 'pobieram_tytuł',\n        'seeElement': 'widzę_element',\n        'dontSeeElement': 'nie_widzę_elementu',\n        'seeInSource': 'widzę_w_źródle',\n        'dontSeeInSource': 'nie_widzę_w_źródle',\n        'executeScript': 'wykonuję_skrypt',\n        'executeAsyncScript': 'wykonuję_skrypt_asynchronicznie',\n        'seeInCurrentUrl': 'widzę_w_adresie_url',\n        'dontSeeInCurrentUrl': 'nie_widzę_w_adresie_url',\n        'seeCurrentUrlEquals': 'widzę_jednakowe_adresy_url',\n        'dontSeeCurrentUrlEquals': 'nie_widzę_jednakowych_adresów_url',\n        'saveScreenshot': 'zapisuję_zrzut_ekranu',\n        'setCookie': 'ustawiam_cookie',\n        'clearCookie': 'usuwam_cookie',\n        'seeCookie': 'widzę_cookie',\n        'dontSeeCookie': 'nie_widzę_cookie',\n        'grabCookie': 'pobieram_cookie',\n        'resizeWindow': 'zmieniam_wielkość_okna',\n        'wait': 'czekam',\n        'haveHeader': 'mam_nagłówek',\n        'clearField': 'czyszczę_pole',\n        'dontSeeElementInDOM': 'nie_widzę_elementu_w_drzewie_DOM',\n        'moveCursorTo': 'przesuwam_kursor_do',\n        'scrollTo': 'skroluję_do'\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/interactive.js":"'use strict';\n\nlet getConfig = require('./utils').getConfig;\nlet getTestRoot = require('./utils').getTestRoot;\nlet recorder = require('../recorder');\nlet Codecept = require('../codecept');\nlet event = require('../event');\nlet output = require('../output');\n\nmodule.exports = function (path, options) {\n\n  process.profile = options.profile;\n\n  let testsPath = getTestRoot(path);\n  let config = getConfig(testsPath);\n  let codecept = new Codecept(config, options);\n  codecept.init(testsPath, function (err) {\n    if (err) {\n      output.error('Error while running bootstrap file :' + err);\n      return;\n    }\n\n    if (options.verbose) output.level(3);\n\n    output.print(\"String interactive shell for current suite...\");\n    recorder.start();\n    event.emit(event.suite.before, {});\n    event.emit(event.test.before);\n    require('../pause')();\n    recorder.add(() => event.emit(event.test.after));\n    recorder.add(() => event.emit(event.suite.after, {}));\n    recorder.add(() => codecept.teardown());\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/list.js":"'use strict';\n\nlet urils = require('../utils');\nlet getConfig = require('./utils').getConfig;\nlet getTestRoot = require('./utils').getTestRoot;\nlet Codecept = require('../codecept');\nlet container = require('../container');\nlet methodsOfObject = require('../utils').methodsOfObject;\nlet getParamNames = require('../utils').getParamNames;\nlet output = require('../output');\n\nmodule.exports = function (path) {\n  let testsPath = getTestRoot(path);\n  let config = getConfig(testsPath);\n  let codecept = new Codecept(config, {});\n  codecept.init(testsPath, function (err) {\n    if (err) {\n      output.error('Error while running bootstrap file :' + err);\n      return;\n    }\n\n    output.print('List of test actions: -- ');\n    let helpers = container.helpers();\n    let suppportI = container.support('I');\n    let actions = [];\n    for (let name in helpers) {\n      let helper = helpers[name];\n      methodsOfObject(helper).forEach((action) => {\n        let params = getParamNames(helper[action]);\n        if (params) params = params.join(', ');\n        actions[action] = 1;\n        output.print(` ${output.colors.grey(name)} I.${output.colors.bold(action)}(${params})`);\n      });\n    }\n    for (let name in suppportI) {\n      if (actions[name]) {\n        continue;\n      }\n      let actor = suppportI[name];\n      let params = getParamNames(actor);\n      if (params) params = params.join(', ');\n      if (!params) params = '';\n      output.print(` I.${output.colors.bold(name)}(${params})`);\n    }\n    output.print('PS: Actions are retrieved from enabled helpers. ');\n    output.print('Implement custom actions in your helper classes.');\n\n    codecept.teardown();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/definitions.js":"'use strict';\n\nlet getConfig = require('./utils').getConfig;\nlet getTestRoot = require('./utils').getTestRoot;\nlet Codecept = require('../codecept');\nlet container = require('../container');\nlet methodsOfObject = require('../utils').methodsOfObject;\nlet getParamNames = require('../utils').getParamNames;\nlet output = require('../output');\nlet fs = require('fs');\nlet path = require('path');\nlet template = `\ntype ICodeceptCallback = (i: CodeceptJS.{{I}}) => void;\n\ndeclare const actor: () => CodeceptJS.{{I}};\ndeclare const Feature: (string: string) => void;\ndeclare const Scenario: (string: string, callback: ICodeceptCallback) => void;\ndeclare const Before: (callback: ICodeceptCallback) => void;\ndeclare const After: (callback: ICodeceptCallback) => void;\ndeclare const within: (selector: string, callback: Function) => void;\n\ndeclare namespace CodeceptJS {\n  export interface {{I}} {\n{{methods}}\n  }\n}\n\ndeclare module \"codeceptjs\" {\n    export = CodeceptJS;\n}\n`;\n\nmodule.exports = function (genPath) {\n  let testsPath = getTestRoot(genPath);\n  let config = getConfig(testsPath);\n  if (!config) return;\n\n  let codecept = new Codecept(config, {});\n  codecept.init(testsPath, function (err) {\n    if (err) {\n      output.error('Error while running bootstrap file :' + err);\n      return;\n    }\n\n    let helpers = container.helpers();\n    let suppportI = container.support('I');\n    let translations = container.translation();\n    let methods = [];\n    let actions = [];\n    for (let name in helpers) {\n      let helper = helpers[name];\n      methodsOfObject(helper).forEach((action) => {\n        let actionAlias = container.translation() ? container.translation().actionAliasFor(action) : action;\n        if (!actions[actionAlias]) {\n          let params = getParamNames(helper[action]);\n          if (params) params = params.join(', ');\n          if (!params) params = '';\n          methods.push(`    ${(actionAlias)}: (${params}) => any; \\n`);\n          actions[actionAlias] = 1;\n        }\n      });\n    }\n    for (let name in suppportI) {\n      if (actions[name]) {\n        continue;\n      }\n      let actor = suppportI[name];\n      let params = getParamNames(actor);\n      if (params) params = params.join(', ');\n      if (!params) params = '';\n      methods.push(`    ${(name)}: (${params}) => any; \\n`);\n    }\n    let definitionsTemplate = template.replace('{{methods}}', methods.join(''));\n    definitionsTemplate = definitionsTemplate.replace(/\\{\\{I\\}\\}/g, container.translation().I);\n\n    fs.writeFileSync(path.join(testsPath, 'steps.d.ts'), definitionsTemplate);\n    output.print('TypeScript Definitions provide autocompletion in Visual Studio Code and other IDEs');\n    output.print('Definitions were generated in steps.d.ts');\n    output.print('Load them by adding at the top of a test file:');\n    output.print(output.colors.grey(`\\n/// <reference path=\"./steps.d.ts\" />`));\n\n    codecept.teardown();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/generate.js":"'use strict';\nlet output = require(\"../output\");\nlet inquirer = require(\"inquirer\");\nlet fs = require('fs');\nlet path = require('path');\nlet colors = require('chalk');\nlet fileExists = require('../utils').fileExists;\nlet ucfirst = require('../utils').ucfirst;\nlet lcfirst = require('../utils').lcfirst;\nlet getConfig = require('./utils').getConfig;\nlet getTestRoot = require('./utils').getTestRoot;\nlet mkdirp = require('mkdirp');\n\nfunction updateConfig(testsPath, config) {\n  let configFile = path.join(testsPath, 'codecept.json');\n  if (!fileExists(configFile)) {\n    console.log();\n    console.log(`${colors.bold.red(`codecept.conf.js config can't be updated automatically`)}`);\n    console.log(`Please add generated object to \"include\" section of a config file`);\n    console.log();\n    return;\n  }\n  console.log(`${colors.yellow(`Updating configuration file...`)}`);\n  return fs.writeFileSync(configFile, JSON.stringify(config, null, 2));\n}\n\nfunction safeFileWrite(file, contents) {\n  if (fileExists(file)) {\n    output.error(`File ${file} already exist, skipping...`);\n    return false;\n  }\n  fs.writeFileSync(file, contents);\n  return true;\n}\n\nlet testTemplate = `\nFeature('{{feature}}');\n\nScenario('test something', ({{actor}}) => {\n\n});\n`;\n\n// generates empty test\nmodule.exports.test = function (genPath) {\n  let testsPath = getTestRoot(genPath);\n  let config = getConfig(testsPath);\n  if (!config) return;\n\n  output.print(`Creating a new test...`);\n  output.print('----------------------');\n\n  let defaultExt = config.tests.match(/\\*(.*?)$/[1])[0] || '_test.js';\n\n  inquirer.prompt([\n    {\n      type: 'input',\n      message: 'Filename of a test',\n      name: 'filename'\n    },\n    {\n      type: 'input',\n      name: 'feature',\n      message: 'Feature which is being tested',\n      default: function (answers) {\n        return ucfirst(answers.filename).replace('_', ' ').replace('-', ' ');\n      }\n    }\n  ], (result) => {\n    let testFilePath = path.dirname(path.join(testsPath, config.tests)).replace(/\\*\\*$/, '');\n    let testFile = path.join(testFilePath, result.filename);\n    let ext = path.extname(testFile);\n    if (!ext) testFile += defaultExt;\n    let dir = path.dirname(testFile);\n    if (!fileExists(dir)) mkdirp.sync(dir);\n    let testContent = testTemplate.replace('{{feature}}', result.feature);\n\n    // can be confusing before translations are documented\n    // commenting it out:\n\n    // let container = require('../container');\n    // container.create(config);\n    // testContent = testContent.replace('{{actor}}', container.translation().I);\n    testContent = testContent.replace('{{actor}}', 'I');\n\n    if (!safeFileWrite(testFile, testContent)) return;\n    output.success(`Test for ${result.filename} was created in ${testFile}`);\n  });\n};\n\nlet pageObjectTemplate = `\n'use strict';\n\nlet I;\n\nmodule.exports = {\n\n  _init() {\n    I = {{actor}}();\n  }\n\n  // insert your locators and methods here\n}\n`;\n\nmodule.exports.pageObject = function (genPath, opts) {\n  let testsPath = getTestRoot(genPath);\n  let config = getConfig(testsPath);\n  let kind = opts.T || 'page';\n  if (!config) return;\n\n  output.print(`Creating a new ${kind} object`);\n  output.print('--------------------------');\n\n  inquirer.prompt([{\n    type: 'input',\n    name: 'name',\n    message: `Name of a ${kind} object`\n  }, {\n    type: 'input',\n    name: 'filename',\n    message: 'Where should it be stored',\n    default: (answers) => {\n      return `./${kind}s/${answers.name}.js`;\n    }\n  }], (result) => {\n    let pageObjectFile = path.join(testsPath, result.filename);\n    let dir = path.dirname(pageObjectFile);\n    if (!fileExists(dir)) fs.mkdirSync(dir);\n\n    let actor = 'actor';\n    if (config.include.I) {\n      let actorPath = config.include.I;\n      if (actorPath.charAt(0) === '.') { // relative path\n        actorPath = path.relative(dir, path.dirname(path.join(testsPath, actorPath))) + actorPath.substring(1); // get an upper level\n      }\n      actor = `require('${actorPath}')`;\n    }\n    if (!safeFileWrite(pageObjectFile, pageObjectTemplate.replace('{{actor}}', actor))) return;\n    let name = lcfirst(result.name) + ucfirst(kind);\n    config.include[name] = result.filename;\n    updateConfig(testsPath, config);\n    output.success(ucfirst(kind) + ` object for ${result.name} was created in ${pageObjectFile}`);\n    output.print(`Use ${output.colors.bold(name)} as parameter in test scenarios to access it`);\n  });\n};\n\nlet helperTemplate = `\n'use strict';\n\nclass {{name}} extends Helper {\n\n  // before/after hooks\n  _before() {\n    // remove if not used\n  }\n\n  _after() {\n    // remove if not used\n  }\n\n  // add custom methods here\n  // If you need to access other helpers\n  // use: this.helpers['helperName']\n\n}\n\nmodule.exports = {{name}};\n`;\n\nmodule.exports.helper = function (genPath) {\n  let testsPath = getTestRoot(genPath);\n  let config = getConfig(testsPath);\n\n  output.print(`Creating a new helper`);\n  output.print('--------------------------');\n\n  inquirer.prompt([{\n    type: 'input',\n    name: 'name',\n    message: `Name of a Helper`\n  }, {\n    type: 'input',\n    name: 'filename',\n    message: 'Where should it be stored',\n    default: (answers) => {\n      return `./${answers.name.toLowerCase()}_helper.js`;\n    }\n  }], (result) => {\n    let name = ucfirst(result.name);\n    let helperFile = path.join(testsPath, result.filename);\n    let dir = path.dirname(helperFile);\n    if (!fileExists(dir)) fs.mkdirSync(dir);\n\n    if (!safeFileWrite(helperFile, helperTemplate.replace(/{{name}}/g, name))) return;\n    config.helpers[name] = {\n      require: result.filename\n    };\n    updateConfig(testsPath, config);\n    output.success(`Helper for ${name} was created in ${helperFile}`);\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/run.js":"'use strict';\nconst getConfig = require('./utils').getConfig;\nconst getTestRoot = require('./utils').getTestRoot;\nconst deepMerge = require('./utils').deepMerge;\nconst fileExists = require('../utils').fileExists;\nconst path = require('path');\nconst fs = require('fs');\nconst Config = require('../config');\nconst Codecept = require('../codecept');\nconst output = require('../output');\n\nmodule.exports = function (test, options) {\n  // registering options globally to use in config\n  process.profile = options.profile;\n  let configFile = options.config;\n  let codecept, outputDir;\n\n  let testRoot = getTestRoot(configFile);\n  let config = getConfig(configFile);\n  if (options.override) {\n    config = Config.append(JSON.parse(options.override));\n  }\n\n  if (!fileExists(outputDir = path.join(testRoot, config.output))) {\n    output.print('creating output directory: ' + outputDir);\n    fs.mkdirSync(outputDir);\n  }\n\n  try {\n    codecept = new Codecept(config, options);\n    codecept.init(testRoot, function (err) {\n      if (err) throw new Error('Error while running bootstrap file :' + err);\n      codecept.loadTests();\n      codecept.run(test);\n    });\n  } catch (err) {\n    output.print('');\n    output.error(err.message);\n    output.print('');\n    output.print(output.colors.grey(err.stack.replace(err.message, '')));\n    process.exit(1);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/command/run-multiple.js":"'use strict';\nlet getConfig = require('./utils').getConfig;\nlet getTestRoot = require('./utils').getTestRoot;\nlet fail = require('./utils').fail;\nlet deepMerge = require('./utils').deepMerge;\nlet Codecept = require('../codecept');\nlet Config = require('../config');\nlet fork = require('child_process').fork;\nlet output = require('../output');\nconst path = require('path');\nconst runner = path.join(__dirname, '/../../bin/codecept');\nlet config, childOpts = {};\nconst copyOptions = ['steps', 'reporter', 'verbose', 'config', 'reporter-options', 'grep', 'fgrep'];\n\n// codeceptjs run:multiple smoke:chrome regression:firefox - will launch smoke suite in chrome and regression in firefox\n// codeceptjs run:multiple smoke:chrome regression - will launch smoke suite in chrome and regression in firefox and chrome\n// codeceptjs run:multiple all - will launch all suites\n// codeceptjs run:multiple smoke regression'\n\nlet suiteId = 1;\n\nmodule.exports = function (suites, options) {\n  // registering options globally to use in config\n  process.profile = options.profile;\n  let configFile = options.config;\n  let codecept;\n\n  let testRoot = getTestRoot(configFile);\n  config = getConfig(configFile);\n\n  let configMultiple = config.multiple;\n\n  if (!configMultiple) {\n    fail(`Multiple suites not configured, add \"multiple\": { /../ } section to config`);\n  }\n\n  // copy opts to run\n  Object.keys(options)\n    .filter((key) => copyOptions.indexOf(key) > -1)\n    .forEach((key) => childOpts[key] = options[key]);\n\n  if (options.all) {\n    suites = Object.keys(configMultiple);\n  }\n  if (!suites.length) {\n    fail('No suites provided. Use --all option to run all configured suites');\n  }\n\n  //iterate options\n  suites.forEach(function (suite) {\n\n    // get suites\n    suite = suite.split(':');\n\n    let suiteName = suite[0];\n    let browser = suite[1];\n    let suiteConf = configMultiple[suiteName];\n\n    if (!suiteConf) {\n      throw new Error(`Suite ${suiteName} was not configured in \"multiple\" section of config`);\n    }\n\n    runSuite(suiteName, suiteConf, browser);\n  });\n};\n\nfunction runSuite(suite, suiteConf, browser) {\n  let suiteBrowsers = suiteConf.browsers.map((b) => typeof b === 'object' ? b.browser : b);\n\n  if (!browser) {\n    // run all browsers in this suite\n    suiteBrowsers.forEach((b) => runSuite(suite, suiteConf, b));\n    return;\n  }\n\n  // clone config\n  let overriddenConfig = Object.assign({}, config);\n\n  if (suiteBrowsers.indexOf(browser) === -1) {\n    throw new Error(`Browser ${browser} not found in multiple suite \"${suite}\" config`);\n  }\n\n  let browserConfig = suiteConf.browsers\n    .map((b) => typeof b === 'object' ? b : { browser: b })\n    .filter((b) => b.browser == browser)[0];\n\n  for (let key in browserConfig) {\n    overriddenConfig.helpers = replaceValue(overriddenConfig.helpers, key, browserConfig[key]);\n  }\n\n  let outputDir = suite + JSON.stringify(browserConfig).replace(/[^\\d\\w]+/g, '_') + suiteId;\n\n  // tweaking default output directories and for mochawesome\n  overriddenConfig = replaceValue(overriddenConfig, 'output', path.join(config.output, outputDir));\n  overriddenConfig = replaceValue(overriddenConfig, 'reportDir', path.join(config.output, outputDir));\n\n  // override grep param and collect all params\n  let params = ['run',\n    '--child', `${suiteId++}.${suite}:${browser}`,\n    '--override', JSON.stringify(overriddenConfig)\n  ];\n\n  Object.keys(childOpts).forEach((key) => {\n    params.push('--' + key);\n    if (childOpts[key] !== true) params.push(childOpts[key]);\n  });\n\n  if (suiteConf.grep) {\n    params.push('--grep');\n    params.push(suiteConf.grep);\n  }\n\n  fork(runner, params, {stdio: [0, 1, 2, 'ipc']})\n    .on('exit', (code) => code === 0 ? null : process.exitCode = 1)\n    .on('error', (err) => process.exitCode = 1);\n}\n\n\n/**\n* search key in object recursive and replace value in it\n*/\nfunction replaceValue(obj, key, value) {\n  if (!obj) return;\n  if (obj instanceof Array) {\n    for (var i in obj) {\n      replaceValue(obj[i], key, value);\n    }\n  }\n  if (obj[key]) obj[key] = value;\n  if (typeof obj === \"object\" && obj !== null) {\n    var children = Object.keys(obj);\n    for (i = 0; i < children.length; i++) {\n      replaceValue(obj[children[i]], key, value);\n    }\n  }\n  return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert.js":"'use strict';\n\nlet output = require('./output');\nlet AssertionFailedError = require('./assert/error');\nlet subs = require('./utils').template;\n\n/**\n * Abstract assertion class introduced for more verbose and customizable messages.\n *\n * Should be easy to extend and use in custom helper classes.\n *\n * Both positive and negative assertions can be used with `assert` and `negate`.\n *\n * Should be used as:\n *\n * ```js\n * let comparator = (a, b) => a === b;\n * let assertion = new Assertion(compare);\n * assertion.assert(1,1);\n * assertion.negate(1,2);\n * ```\n *\n * Additional parameters can be passed to constructor or to assert/negate methods\n * to get more customizable exception messages.\n *\n */\nclass Assertion {\n\n  constructor(comparator, params) {\n    this.comparator = comparator;\n    this.params = params || {};\n    this.params.customMessage = '';\n  }\n\n  /**\n   * Performs positive assertion.\n   * Fails if comparator function with provided arguments returns false\n   */\n  assert() {\n    this.addAssertParams.apply(this, arguments);\n    let result = this.comparator.apply(this.params, arguments);\n    if (result) return; // should increase global assetion counter\n    throw this.getFailedAssertion();\n  }\n\n  /**\n   * Performs negative assertion.\n   * Fails if comparator function with provided arguments returns true\n   */\n  negate() {\n    this.addAssertParams.apply(this, arguments);\n    let result = this.comparator.apply(this.params, arguments);\n    if (!result) return; // should increase global assetion counter\n    throw this.getFailedNegation();\n  }\n\n  /**\n   * Used to save additional parameters passed to assert/negate\n   */\n  addAssertParams() {}\n\n  getException() {\n    return new AssertionFailedError(this.params, '');\n  }\n\n  getFailedNegation() {\n    let err = this.getException();\n    err.params.type = 'not ' + err.params.type;\n    return err;\n  }\n\n  getFailedAssertion() {\n    return this.getException();\n  }\n\n}\n\nmodule.exports = Assertion;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/scenario.js":"'use strict';\nlet event = require('./event');\nlet container = require('./container');\nlet recorder = require('./recorder');\nlet getParamNames = require('./utils').getParamNames;\n\n/**\n * Wraps test function, injects support objects from container,\n * starts promise chain with recorder, performs before/after hooks\n * through event system.\n */\nmodule.exports.test = (test) => {\n  let testFn = test.fn;\n  if (!testFn) {\n    return test;\n  }\n\n  test.steps = [];\n\n  test.fn = function (done) {\n    recorder.errHandler(function (err) {\n      recorder.session.start('teardown');\n      event.emit(event.test.failed, test, err);\n      recorder.add(() => done(err));\n    });\n\n    try {\n      event.emit(event.test.started, test);\n      let res = testFn.apply(test, getInjectedArguments(testFn));\n      if (isGenerator(testFn)) {\n        try {\n          res.next(); // running test\n        } catch (err) {\n          event.emit(event.test.failed, test, err);\n          done(err);\n          return test;\n        }\n        recorder.catch(); // catching possible errors in promises\n        let resumeTest = function () {\n          recorder.add('create new promises queue for generator', function (data) {\n            recorder.session.start('generator'); // creating a new promise chain\n            try {\n              let resume = res.next(data);\n              if (resume.done) {\n                recorder.add('fire test.passed', () => event.emit(event.test.passed, test));\n                recorder.add('finish generator with no error', () => done()); // finish him\n              } else {\n                resumeTest();\n              }\n            } catch (err) {\n              recorder.throw(err); // catch error in test and rethrow into promise\n            }\n            recorder.catch(); // handle all errors in promise chain\n          });\n        };\n        resumeTest();\n      }\n    } catch (err) {\n      recorder.throw(err);\n    } finally {\n      if (!isGenerator(testFn)) {\n        recorder.add('fire test.passed', () => event.emit(event.test.passed, test));\n        recorder.add('finish test', () => done());\n        recorder.catch();\n      }\n    }\n  };\n  return test;\n};\n\n/**\n * Injects arguments to function from controller\n */\nmodule.exports.injected = function (fn, suite) {\n  return function () {\n    try {\n      fn.apply(this, getInjectedArguments(fn));\n    } catch (err) {\n      recorder.throw(err);\n    }\n    recorder.catch((err) => {\n      event.emit(event.test.failed, suite, err); // emit\n      throw err;\n    });\n    return recorder.promise();\n  };\n};\n\n/**\n * Starts promise chain, so helpers could enqueue their hooks\n */\nmodule.exports.setup = function () {\n  recorder.start();\n  event.emit(event.test.before);\n};\n\nmodule.exports.teardown = function () {\n  event.emit(event.test.after);\n};\n\nmodule.exports.suiteSetup = function () {\n  recorder.start();\n  event.emit(event.suite.before);\n};\n\nmodule.exports.suiteTeardown = function () {\n  recorder.start();\n  event.emit(event.suite.after);\n};\n\nfunction isGenerator(fn) {\n  return fn.constructor.name === 'GeneratorFunction';\n}\n\nfunction getInjectedArguments(fn) {\n  let testArguments = [];\n  let params = getParamNames(fn) || [];\n  let objects = container.support();\n  for (var key in params) {\n    let obj = params[key];\n    if (!objects[obj]) {\n      throw new Error(`Object of type ${obj} is not defined in container`);\n    }\n    testArguments.push(container.support(obj));\n  }\n  return testArguments;\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert/empty.js":"'use strict';\nlet Assertion = require('../assert');\nlet AssertionFailedError = require('./error');\nlet template = require('../utils').template;\nlet output = require('../output');\n\nclass EmptinessAssertion extends Assertion {\n\n  constructor(params) {\n    super(function (value) {\n      if (Array.isArray(value)) {\n        return value.length === 0;\n      }\n      return !value;\n    }, params);\n    this.params.type = 'to be empty';\n  }\n\n  getException() {\n    if (Array.isArray(this.params.value)) {\n      this.params.value = '[' + this.params.value.join(', ') + ']';\n    }\n\n    let err = new AssertionFailedError(this.params, \"{{customMessage}}expected {{subject}} '{{value}}' {{type}}\");\n\n    err.cliMessage = () => {\n      let msg = err.template\n        .replace('{{value}}', output.colors.bold('{{value}}'))\n        .replace('{{subject}}', output.colors.bold('{{subject}}'));\n      return template(msg, this.params);\n    };\n    return err;\n  }\n\n\n  addAssertParams() {\n    this.params.value = this.params.actual = arguments[0];\n    this.params.expected = [];\n    this.params.customMessage = arguments[1] ? arguments[1] + \"\\n\\n\" : '';\n  }\n}\n\nmodule.exports = {\n  Assertion: EmptinessAssertion,\n  empty: (subject) => {\n    return new EmptinessAssertion({subject});\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert/equal.js":"'use strict';\nlet Assertion = require('../assert');\nlet AssertionFailedError = require('./error');\nlet template = require('../utils').template;\nlet output = require('../output');\n\nclass EqualityAssertion extends Assertion {\n\n  constructor(params) {\n    let comparator = function (a, b) {\n      return a === b;\n    };\n    super(comparator, params);\n    this.params.type = 'to equal';\n  }\n\n  getException() {\n    let params = this.params;\n    params.jar = template(params.jar, params);\n    let err = new AssertionFailedError(params, \"{{customMessage}}expected {{jar}} '{{expected}}' {{type}} '{{actual}}'\");\n    err.showDiff = false;\n    err.cliMessage = () => {\n      let msg = err.template\n        .replace('{{jar}}', output.colors.bold('{{jar}}'));\n      return template(msg, this.params);\n    };\n    return err;\n  }\n\n  addAssertParams() {\n    this.params.expected = arguments[0];\n    this.params.actual = arguments[1];\n    this.params.customMessage = arguments[2] ? arguments[2] + \"\\n\\n\" : '';\n  }\n}\n\nmodule.exports = {\n  Assertion: EqualityAssertion,\n  equals: (jar) => {\n    return new EqualityAssertion({ jar });\n  },\n  urlEquals: (baseUrl) => {\n    let assert = new EqualityAssertion({ jar: 'url of current page' });\n    assert.comparator = function (expected, actual) {\n      if (expected.indexOf('http') !== 0) {\n        actual = actual.slice(actual.indexOf(baseUrl) + baseUrl.length);\n      }\n      return actual === expected;\n    };\n    return assert;\n  },\n  fileEquals: (file) => {\n    return new EqualityAssertion({ file, jar: \"contents of {{file}}\" }\n  );\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert/include.js":"'use strict';\nlet Assertion = require('../assert');\nlet AssertionFailedError = require('./error');\nlet template = require('../utils').template;\nlet output = require('../output');\n\nconst MAX_LINES = 10;\n\n\nclass InclusionAssertion extends Assertion {\n\n  constructor(params) {\n    params.jar = params.jar || 'string';\n    let comparator = function (needle, haystack) {\n      if (Array.isArray(haystack)) {\n        return haystack.filter(part => part.indexOf(needle) >= 0).length > 0;\n      }\n      return haystack.indexOf(needle) >= 0;\n    };\n    super(comparator, params);\n    this.params.type = 'to include';\n  }\n\n  getException() {\n    let params = this.params;\n    params.jar = template(params.jar, params);\n    let err = new AssertionFailedError(params, '{{customMessage}}expected {{jar}} {{type}} \"{{needle}}\"');\n    err.expected = params.needle;\n    err.actual = params.haystack;\n    if (Array.isArray(this.params.haystack)) {\n      this.params.haystack = this.params.haystack.join(\"\\n___(next element)___\\n\");\n    }\n    err.cliMessage = function () {\n      let msg = this.template\n        .replace('{{jar}}', output.colors.bold('{{jar}}'))\n        .replace('{{needle}}', output.colors.bold('{{needle}}'));\n      return template(msg, this.params);\n    };\n    return err;\n  }\n\n  getFailedAssertion() {\n    let err = this.getException();\n    let lines = this.params.haystack.split(\"\\n\");\n    if (lines.length > MAX_LINES) {\n      let more = lines.length - MAX_LINES;\n      err.actual = lines.slice(0, MAX_LINES).join(\"\\n\") + `\\n--( ${more} lines more )---`;\n    }\n    return err;\n  }\n\n  getFailedNegation() {\n    this.params.type = 'not to include';\n    let err = this.getException();\n    let pattern = new RegExp(\"^.*?\\n?^.*?\\n?^.*?\" + escapeRegExp(this.params.needle) + \".*?$\\n?.*$\\n?.*$\", \"m\");\n    let matched = this.params.haystack.match(pattern);\n    if (!matched) return err;\n    err.actual = matched[0].replace(this.params.needle, output.colors.bold(this.params.needle));\n    err.actual = `------\\n${err.actual}\\n------`;\n    return err;\n  }\n\n  addAssertParams() {\n    this.params.needle = arguments[0];\n    this.params.haystack = arguments[1];\n    this.params.customMessage = arguments[2] ? arguments[2] + \"\\n\\n\" : '';\n  }\n}\n\nmodule.exports = {\n  Assertion: InclusionAssertion,\n  includes: (needleType) => {\n    needleType = needleType || 'string';\n    return new InclusionAssertion({jar: needleType});\n  },\n  fileIncludes: (file) => {\n    return new InclusionAssertion({ file, jar: \"file {{file}}\" }\n      );\n  }\n};\n\nfunction escapeRegExp(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/assert/truth.js":"'use strict';\nlet Assertion = require('../assert');\nlet AssertionFailedError = require('./error');\nlet template = require('../utils').template;\nlet output = require('../output');\n\nclass TruthAssertion extends Assertion {\n\n  constructor(params) {\n    super(function (value) {\n      if (Array.isArray(value)) {\n        return value.filter((val) => !!val).length > 0;\n      }\n      return !!value;\n    }, params);\n    this.params.type = this.params.type || 'to be true';\n  }\n\n  getException() {\n    let err = new AssertionFailedError(this.params, \"{{customMessage}}expected {{subject}} {{type}}\");\n    err.cliMessage = () => {\n      let msg = err.template\n        .replace('{{subject}}', output.colors.bold('{{subject}}'));\n      return template(msg, this.params);\n    };\n    return err;\n  }\n\n  addAssertParams() {\n    this.params.value = this.params.actual = arguments[0];\n    this.params.expected = true;\n    this.params.customMessage = arguments[1] ? arguments[1] + \"\\n\\n\" : '';\n  }\n}\n\nmodule.exports = {\n  Assertion: TruthAssertion,\n  truth: (subject, type) => {\n    return new TruthAssertion({subject, type});\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper/FileSystem.js":"'use strict';\nlet Helper = require('../helper');\nlet fileExists = require('../utils').fileExists;\nlet fileIncludes = require('../assert/include').fileIncludes;\nlet fileEquals = require('../assert/equal').fileEquals;\nlet assert = require('assert');\nlet path = require('path');\nlet fs = require('fs');\n\n/**\n * Helper for testing filesystem.\n * Can be easily used to check file structures:\n *\n * ```js\n * I.amInPath('test');\n * I.seeFile('codecept.json');\n * I.seeInThisFile('FileSystem');\n * I.dontSeeInThisFile(\"WebDriverIO\");\n * ```\n */\nclass FileSystem extends Helper {\n\n  _before() {\n    this.dir = global.codecept_dir;\n    this.file = null;\n    this.debugSection('Dir', this.dir);\n  }\n\n  /**\n   * Enters a directory In local filesystem.\n   * Starts from a current directory\n   */\n  amInPath(openPath) {\n    this.dir = path.join(global.codecept_dir, openPath);\n    this.debugSection('Dir', this.dir);\n  }\n\n  /**\n   * Writes test to file\n   */\n  writeToFile(name, text) {\n    fs.writeFileSync(path.join(this.dir, name), text);\n  }\n\n  /**\n   * Checks that file exists\n   */\n  seeFile(name) {\n    this.file = path.join(this.dir, name);\n    this.debugSection('File', this.file);\n    assert.ok(fileExists(this.file), `File ${name} not found in ${this.dir}`);\n  }\n\n  /**\n   * Checks that file found by `seeFile` includes a text.\n   */\n  seeInThisFile(text, encoding) {\n    let content = getFileContents(this.file, encoding);\n    fileIncludes(this.file).assert(text, content);\n  }\n\n  /**\n   * Checks that file found by `seeFile` doesn't include text.\n   */\n  dontSeeInThisFile(text, encoding) {\n    let content = getFileContents(this.file, encoding);\n    fileIncludes(this.file).negate(text, content);\n  }\n\n  /**\n   * Checks that contents of file found by `seeFile` equal to text.\n   */\n  seeFileContentsEqual(text, encoding) {\n    let content = getFileContents(this.file, encoding);\n    fileEquals(this.file).assert(text, content);\n  }\n\n  /**\n   * Checks that contents of file found by `seeFile` doesn't equal to text.\n   */\n  dontSeeFileContentsEqual(text, encoding) {\n    let content = getFileContents(this.file, encoding);\n    fileEquals(this.file).negate(text, content);\n  }\n\n}\n\nfunction getFileContents(file, encoding) {\n  if (!file) assert.fail(`No files were opened, please use seeFile action`);\n  encoding = encoding || 'utf8';\n  return fs.readFileSync(file, 'utf8');\n\n}\n\nmodule.exports = FileSystem;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper/Nightmare.js":"'use strict';\nconst requireg = require('requireg');\nconst Helper = require('../helper');\nconst stringIncludes = require('../assert/include').includes;\nconst urlEquals = require('../assert/equal').urlEquals;\nconst equals = require('../assert/equal').equals;\nconst empty = require('../assert/empty').empty;\nconst truth = require('../assert/truth').truth;\nconst xpathLocator = require('../utils').xpathLocator;\nconst fileExists = require('../utils').fileExists;\nconst co = require('co');\nconst path = require('path');\n\nlet specialKeys = {\n  Backspace: '\\u0008',\n  Enter: '\\u000d',\n  Delete: '\\u007f'\n};\n\n/**\n * Nightmare helper wraps [Nightmare](https://github.com/segmentio/nightmare) library to provide\n * fastest headless testing using Electron engine. Unlike Selenium-based drivers this uses\n * Chromium-based browser with Electron with lots of client side scripts, thus should be less stable and\n * less trusted.\n *\n * Requires `nightmare` and `nightmare-upload` packages to be installed.\n *\n * ### Configuration\n *\n * This helper should be configured in codecept.json\n *\n * * `url` - base url of website to be tested\n * * `restart` (optional, default: true) - restart browser between tests.\n * * `keepCookies` (optional, default: false)  - keep cookies between tests when `restart` set to false.\n * * `waitForAction`: (optional) how long to wait after click, doubleClick or PressKey actions in ms. Default: 500\n * * `waitForTimeout`: (optional) default wait* timeout\n * * `windowSize`: (optional) default window size. Set a dimension like `640x480`.\n *\n * + options from [Nightmare configuration](https://github.com/segmentio/nightmare#api)\n *\n */\nclass Nightmare extends Helper {\n\n  constructor(config) {\n    super(config);\n\n    // set defaults\n    this.options = {\n      waitForAction: 500,\n      waitForTimeout: 1000,\n      rootElement: 'body',\n      restart: true,\n      keepCookies: false,\n      js_errors: null\n    };\n\n    // override defaults with config\n    Object.assign(this.options, config);\n\n    this.context = this.options.rootElement;\n    this.options.waitForTimeout;\n  }\n\n  static _config() {\n    return [\n      { name: 'url', message: \"Base url of site to be tested\", default: 'http://localhost' },\n    ];\n  }\n\n  static _checkRequirements() {\n    try {\n      requireg(\"nightmare\");\n      requireg(\"nightmare-upload\");\n    } catch(e) {\n      return [\"nightmare\", \"nightmare-upload\"];\n    }\n  }\n\n  _init() {\n    this.Nightmare = requireg('nightmare');\n\n    require('nightmare-upload')(this.Nightmare);\n\n    this.Nightmare.action('findElements', function (locator, contextEl, done) {\n\n      if (!done) {\n        done = contextEl;\n        contextEl = null;\n      }\n\n      let by = Object.keys(locator)[0];\n      let value = locator[by];\n\n      this.evaluate_now(function (by, locator, contextEl) {\n        return window.codeceptjs.findAndStoreElements(by, locator);\n      }, done, by, value, contextEl);\n    });\n\n    this.Nightmare.action('findElement', function (locator, contextEl, done) {\n      if (!done) {\n        done = contextEl;\n        contextEl = null;\n      }\n\n      let by = Object.keys(locator)[0];\n      let value = locator[by];\n\n      this.evaluate_now(function (by, locator, contextEl) {\n        let res = window.codeceptjs.findAndStoreElement(by, locator);\n        if (res === null) {\n          throw new Error(`Element ${locator} couldn't be located by ${by}`);\n        }\n        return res;\n      }, done, by, value, contextEl);\n    });\n\n    this.Nightmare.action('asyncScript', function () {\n      let args = Array.prototype.slice.call(arguments);\n      let done = args.pop();\n      args = args.splice(1, 0, done);\n      this.evaluate_now.apply(this, args);\n    });\n\n    this.Nightmare.action('enterText', function (el, text, clean, done) {\n\n      let child = this.child;\n      let typeFn = () => child.call('type', text, done);\n\n      this.evaluate_now(function (el, clean) {\n        var el = window.codeceptjs.fetchElement(el);\n        if (clean) el.value = '';\n        el.focus();\n      }, () => {\n        if (clean) return typeFn();\n        child.call('pressKey', 'End', typeFn); // type End before\n      }, el, clean);\n    });\n\n    this.Nightmare.action('pressKey', function (ns, options, parent, win, renderer, done) {\n      parent.respondTo('pressKey', function (ch, done) {\n        win.webContents.sendInputEvent({\n          type: 'keyDown',\n          keyCode: ch\n        });\n\n        win.webContents.sendInputEvent({\n          type: 'char',\n          keyCode: ch\n        });\n\n        win.webContents.sendInputEvent({\n          type: 'keyUp',\n          keyCode: ch\n        });\n        done();\n      });\n      done();\n    }, function (key, done) {\n      this.child.call('pressKey', key, done);\n    });\n  }\n\n  _beforeSuite() {\n    if (!this.options.restart) {\n      return this._startBrowser();\n    }\n  }\n\n  _before() {\n    if (this.options.restart) {\n      return this._startBrowser();\n    }\n    return this.browser;\n  }\n\n  _after() {\n    if (this.options.restart) {\n      return this._stopBrowser();\n    }\n    if (this.options.keepCookies) return;\n    return this.browser.cookies.clearAll();\n  }\n\n  _afterSuite() {\n    if (!this.options.restart) {\n      this._stopBrowser();\n    }\n  }\n\n  _startBrowser() {\n    this.browser = this.Nightmare(this.options);\n    this.browser.on('dom-ready', () => this._injectClientScripts());\n    this.browser.on('console', (type, message) => {\n      this.debug(`${type}: ${message}`);\n    });\n\n    if (this.options.windowSize) {\n      let size = this.options.windowSize.split('x');\n      return this.browser.viewport(parseInt(size[0]), parseInt(size[1]));\n    }\n  }\n\n  _stopBrowser() {\n    return this.browser.end().catch((error) => {\n      this.debugSection('Error on End', error);\n    });\n  }\n\n  _withinBegin(locator) {\n    this.context = locator;\n    locator = guessLocator(locator) || {css: locator};\n    this.browser.evaluate(function (by, locator) {\n      var el = codeceptjs.findElement(by, locator);\n      if (!el) throw new Error(`Element by ${by}: ${locator} not found`);\n      window.codeceptjs.within = el;\n    }, lctype(locator), lcval(locator));\n  }\n\n  _withinEnd() {\n    this.context = this.options.rootElement;\n    return this.browser.evaluate(function () {\n      codeceptjs.within = null;\n    });\n  }\n\n  /**\n   * Locate elements by different locator types, including strict locator.\n   * Should be used in custom helpers.\n   *\n   * This method return promise with array of IDs of found elements.\n   * Actual elements can be accessed inside `evaluate` by using `codeceptjs.fetchElement()`\n   * client-side function:\n   *\n   * ```js\n   * // get an inner text of an element\n   *\n   * let browser = this.helpers['Nightmare'].browser;\n   * let value = this.helpers['Nightmare']._locate({name: 'password'}).then(function(els) {\n   *   return browser.evaluate(function(el) {\n   *     return codeceptjs.fetchElement(el).value;\n   *   }, els[0]);\n   * });\n   * ```\n   */\n  _locate(locator) {\n    locator = guessLocator(locator) || { css: locator};\n    return this.browser.evaluate(function (by, locator) {\n      return codeceptjs.findElements(by, locator);\n    }, lctype(locator), lcval(locator));\n  }\n\n\n  /**\n   * Add a header override for all HTTP requests. If header is undefined, the header overrides will be reset.\n   *\n   * ```js\n   * I.haveHeader('x-my-custom-header', 'some value');\n   * I.haveHeader(); // clear headers\n   * ```\n   */\n  haveHeader(header, value) {\n    return this.browser.header(header, value);\n  }\n\n  /**\n   * {{> ../webapi/amOnPage }}\n   *\n   * In a second argument a list of request headers can be passed:\n   *\n   * ```js\n   * I.amOnPage('/auth', [{'x-my-custom-header': 'some value'}])\n   * ```\n   */\n  amOnPage(url, headers) {\n    if (url.indexOf('http') !== 0) {\n      url = this.options.url + url;\n    }\n    return this.browser.goto(url, headers).then((res) => {\n      this.debugSection('URL', res.url);\n      this.debugSection('Code', res.code);\n      this.debugSection('Headers', JSON.stringify(res.headers));\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInTitle }}\n   */\n  seeInTitle(text) {\n    return this.browser.title().then((title) => stringIncludes('web page title').assert(text, title));\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInTitle }}\n   */\n  dontSeeInTitle(text) {\n    return this.browser.title().then((title) => stringIncludes('web page title').negate(text, title));\n  }\n\n  /**\n   * {{> ../webapi/grabTitle }}\n   */\n  grabTitle() {\n    return this.browser.title();\n  }\n\n  /**\n   * {{> ../webapi/seeInCurrentUrl }}\n   */\n  seeInCurrentUrl(url) {\n    return this.browser.url().then(function (currentUrl) {\n      return stringIncludes('url').assert(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInCurrentUrl }}\n   */\n  dontSeeInCurrentUrl(url) {\n    return this.browser.url().then(function (currentUrl) {\n      return stringIncludes('url').negate(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeCurrentUrlEquals }}\n   */\n  seeCurrentUrlEquals(url) {\n    return this.browser.url().then((currentUrl) => {\n      return urlEquals(this.options.url).assert(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCurrentUrlEquals }}\n   */\n  dontSeeCurrentUrlEquals(url) {\n    return this.browser.url().then((currentUrl) => {\n      return urlEquals(this.options.url).negate(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/see }}\n   */\n  see(text, context) {\n    return proceedSee.call(this, 'assert', text, context);\n  }\n\n  /**\n   * {{> ../webapi/dontSee }}\n   */\n  dontSee(text, context) {\n    return proceedSee.call(this, 'negate', text, context);\n  }\n\n  /**\n   * {{> ../webapi/seeElement }}\n   */\n  seeElement(locator) {\n    locator = guessLocator(locator) || { css: locator};\n    return this.browser.evaluate(function (by, locator) {\n      return codeceptjs.findElements(by, locator).filter((e) => e.offsetParent !== null).length;\n    }, lctype(locator), lcval(locator)).then((num) => {\n      return equals('number of elements on a page').negate(0, num);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElement }}\n   */\n  dontSeeElement(locator) {\n    locator = guessLocator(locator) || { css: locator};\n    return this.browser.evaluate(function (by, locator) {\n      return codeceptjs.findElements(by, locator).filter((e) => e.offsetParent !== null).length;\n    }, lctype(locator), lcval(locator)).then((num) => {\n      return equals('number of elements on a page').assert(0, num);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeElementInDOM }}\n   */\n  seeElementInDOM(locator) {\n    return this.browser.findElements(guessLocator(locator) || {css: locator}).then((els) => {\n      return empty('elements').negate(els.fill('ELEMENT'));\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElementInDOM }}\n   */\n  dontSeeElementInDOM(locator) {\n    return this.browser.findElements(guessLocator(locator) || {css: locator}).then((els) => {\n      return empty('elements').assert(els.fill('ELEMENT'));\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInSource }}\n   */\n  seeInSource(text) {\n    return this.browser.evaluate(function () {\n      return document.documentElement.outerHTML;\n    }).then((source) => {\n      return stringIncludes('HTML source of a page').assert(text, source);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInSource }}\n   */\n  dontSeeInSource(text) {\n    return this.browser.evaluate(function () {\n      return document.documentElement.outerHTML;\n    }).then((source) => {\n      return stringIncludes('HTML source of a page').negate(text, source);\n    });\n  }\n\n\n  /**\n   * {{> ../webapi/click }}\n   */\n  click(locator, context) {\n    if (context) {\n      context = guessLocator(context) || {css: context};\n    }\n    return co(findClickable.call(this, locator, context)).then((el) => {\n      if (el === null) throw new Error(`Clickable element \"${locator}\" not found by name|text|title|CSS|XPath`);\n      return this.browser.evaluate(function (el) {\n        return window.codeceptjs.clickEl(el);\n      }, el).wait(this.options.waitForAction); // wait for click event to happen\n    });\n  }\n\n  /**\n   * {{> ../webapi/doubleClick }}\n   */\n  doubleClick(locator, context) {\n    if (context) {\n      context = guessLocator(context) || {css: context};\n    }\n    return co(findClickable.call(this, locator, context)).then((el) => {\n      if (el === null) throw new Error(`Clickable element \"${locator}\" not found by name|text|title|CSS|XPath`);\n      return this.browser.evaluate(function (el) {\n        return window.codeceptjs.doubleClickEl(el);\n      }, el).wait(this.options.waitForAction); // wait for click event to happen\n    });\n  }\n\n  /**\n   * {{> ../webapi/moveCursorTo }}\n   */\n  moveCursorTo(locator, offsetX, offsetY) {\n    return this.browser.findElement(guessLocator(locator) || { css: locator}).then((el) => {\n      if (el === null) throw new Error(`Element ${locator} not found`);\n      return this.browser.evaluate(function (el, x, y) {\n        return window.codeceptjs.hoverEl(el, x, y);\n      }, el, offsetX, offsetY).wait(this.options.waitForAction); // wait for hover event to happen\n    });\n  }\n\n\n  /**\n   * {{> ../webapi/executeScript }}\n   *\n   * Wrapper for synchronous [evaluate](https://github.com/segmentio/nightmare#evaluatefn-arg1-arg2)\n   */\n  executeScript(fn) {\n    return this.browser.evaluate.apply(this.browser, arguments);\n  }\n\n  /**\n   * {{> ../webapi/executeAsyncScript }}\n   *\n   * Wrapper for asynchronous [evaluate](https://github.com/segmentio/nightmare#evaluatefn-arg1-arg2).\n   * Unlike NightmareJS implementation calling `done` will return its first argument.\n   */\n  executeAsyncScript(fn) {\n    return this.browser.evaluate.apply(this.browser, arguments)\n      .catch((err) => err); // Nightmare's first argument is error :(\n  }\n\n  /**\n   * {{> ../webapi/resizeWindow }}\n   */\n  resizeWindow(width, height) {\n    if (width === 'maximize') {\n      throw new Error(`Nightmare doesn't support resizeWindow to maximum!`);\n    }\n    return this.browser.viewport(width, height);\n  }\n\n  /**\n   * {{> ../webapi/checkOption }}\n   */\n  checkOption(field, context) {\n    if (context) {\n      context = guessLocator(context) || {css: context};\n    }\n    return co(findCheckable.call(this, field, context)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Option ${field} not found by name|text|CSS|XPath`);\n      }\n      return this.browser.evaluate(function (els) {\n        window.codeceptjs.checkEl(els[0]);\n      }, els);\n    });\n  }\n\n  /**\n   * {{> ../webapi/fillField }}\n   */\n  fillField(field, value) {\n    return co(findFields(this.browser, field)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      return this.browser.enterText(els[0], value, true);\n    });\n  }\n\n  /**\n   * {{> ../webapi/clearField }}\n   */\n  clearField(field) {\n    return this.fillField(field, '');\n  }\n\n  /**\n   * {{> ../webapi/appendField }}\n   */\n  appendField(field, value) {\n    return co(findFields(this.browser, field)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      return this.browser.enterText(els[0], value, false);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInField }}\n   */\n  seeInField(field, value) {\n    return co.wrap(proceedSeeInField).call(this, 'assert', field, value);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInField }}\n   */\n  dontSeeInField(field, value) {\n    return co.wrap(proceedSeeInField).call(this, 'negate', field, value);\n  }\n\n  /**\n   * Sends [input event](http://electron.atom.io/docs/api/web-contents/#webcontentssendinputeventevent) on a page.\n   * Can submit special keys like 'Enter', 'Backspace', etc\n   */\n  pressKey(key) {\n    if (Array.isArray(key)) {\n      key = key.join('+'); // should work with accelerators...\n    }\n    if (Object.keys(specialKeys).indexOf(key) >= 0) {\n      key = specialKeys[key];\n    }\n    return this.browser.pressKey(key).wait(this.options.waitForAction);\n  }\n\n  /**\n   * {{> ../webapi/seeCheckboxIsChecked }}\n   */\n  seeCheckboxIsChecked(field) {\n    return co.wrap(proceedIsChecked).call(this, 'assert', field);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCheckboxIsChecked }}\n   */\n  dontSeeCheckboxIsChecked(field) {\n    return co.wrap(proceedIsChecked).call(this, 'negate', field);\n  }\n\n  /**\n   * {{> ../webapi/attachFile }}\n   *\n   * ##### Limitations:\n   *\n   * * works only with CSS selectors.\n   * * doesn't work if the Chromium DevTools panel is open (as Chromium allows only one attachment to the debugger at a time. [See more](https://github.com/rosshinkley/nightmare-upload#important-note-about-setting-file-upload-inputs))\n   */\n  attachFile(locator, pathToFile) {\n    let file = path.join(global.codecept_dir, pathToFile);\n\n    if (!isCSS(locator)) {\n      throw new Error(`Only CSS locator allowed for attachFile in Nightmare helper`);\n    }\n\n    if (!fileExists(file)) {\n      throw new Error(`File at ${file} can not be found on local system`);\n    }\n    return this.browser.upload(locator, file);\n  }\n\n  /**\n   * {{> ../webapi/grabTextFrom }}\n   */\n  grabTextFrom(locator) {\n    return this.browser.findElement(guessLocator(locator) || { css: locator}).then((el) => {\n      return this.browser.evaluate(function (el) {\n        return codeceptjs.fetchElement(el).innerText;\n      }, el);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabValueFrom }}\n   */\n  grabValueFrom(locator) {\n    return co(findFields(this.browser, locator)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Field ${locator} was not located by name|label|CSS|XPath`);\n      }\n      return this.browser.evaluate(function (el) {\n        return codeceptjs.fetchElement(el).value;\n      }, els[0]);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabAttributeFrom }}\n   */\n  grabAttributeFrom(locator, attr) {\n    return this.browser.findElement(guessLocator(locator) || { css: locator}).then((el) => {\n      return this.browser.evaluate(function (el, attr) {\n        return codeceptjs.fetchElement(el).getAttribute(attr);\n      }, el, attr);\n    });\n  }\n\n\n  _injectClientScripts() {\n    return this.browser.inject('js', path.join(__dirname, 'clientscripts', 'nightmare.js'));\n  }\n\n  /**\n   * {{> ../webapi/selectOption }}\n   */\n  selectOption(select, option) {\n    let fetchAndCheckOption = function (el, locator) {\n      el = codeceptjs.fetchElement(el);\n      let found = document.evaluate(locator, el, null, 5);\n      var current = null;\n      var items = [];\n      while (current = found.iterateNext()) {\n        items.push(current);\n      }\n      for (var i = 0; i < items.length; items++) {\n        current = items[i];\n        current.selected = true;\n        var event = document.createEvent('HTMLEvents');\n        if (!el.multiple) el.value = current.value;\n        event.initEvent('change', true, true);\n        el.dispatchEvent(event);\n      }\n      return !!current;\n    };\n    let browser = this.browser;\n    return co(findFields(this.browser, select)).then(co.wrap(function*(fields) {\n      if (!fields.length) {\n        throw new Error(`Selectable field ${select} not found by name|text|CSS|XPath`);\n      }\n      if (!Array.isArray(option)) {\n        option = [option];\n      }\n      let field = fields[0];\n      let promises = [];\n      for (let key in option) {\n        let opt = option[key];\n        let normalizedText = `[normalize-space(.) = \"${opt.trim() }\"]`;\n        let byVisibleText = `./option${normalizedText}|./optgroup/option${normalizedText}`;\n\n        let checked = yield browser.evaluate(fetchAndCheckOption, field, byVisibleText);\n\n        if (!checked) {\n          let normalizedValue = `[normalize-space(@value) = \"${opt.trim() }\"]`;\n          let byValue = `./option${normalizedValue}|./optgroup/option${normalizedValue}`;\n          yield browser.evaluate(fetchAndCheckOption, field, byValue);\n        }\n      }\n    }));\n  }\n\n  /**\n   * {{> ../webapi/setCookie }}\n   *\n   * Wrapper for `.cookies.set(cookie)`.\n   * [See more](https://github.com/segmentio/nightmare/blob/master/Readme.md#cookiessetcookie)\n   */\n  setCookie(cookie) {\n    return this.browser.cookies.set(cookie);\n  }\n\n  /**\n   * {{> ../webapi/seeCookie}}\n   *\n   */\n  seeCookie(name) {\n    return this.browser.cookies.get(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').assert(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCookie}}\n   */\n  dontSeeCookie(name) {\n    return this.browser.cookies.get(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').negate(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabCookie}}\n   *\n   * Returns cookie in JSON format. If name not passed returns all cookies for this domain.\n   *\n   * Multiple cookies can be received by passing query object:\n   *\n   * ```js\n   * I.grabCookie({ secure: true});\n   * ```\n   *\n   * If you'd like get all cookies for all urls, use: `.grabCookie({ url: null }).`\n   */\n  grabCookie(name) {\n    return this.browser.cookies.get(name);\n  }\n\n  /**\n   * {{> ../webapi/clearCookie}}\n   */\n  clearCookie(cookie) {\n    if (!cookie) {\n      return this.browser.cookies.clearAll();\n    }\n    return this.browser.cookies.clear(cookie);\n  }\n\n  /**\n   * {{> ../webapi/wait }}\n   */\n  wait(sec) {\n    return new Promise(function (done) {\n      setTimeout(done, sec * 1000);\n    });\n  }\n\n  /**\n   * {{> ../webapi/waitForText }}\n   */\n  waitForText(text, sec, context) {\n    if (!context) {\n      context = this.context;\n    }\n    let locator = guessLocator(context) || { css: context};\n    this.browser.options.waitTimeout = sec * 1000 || this.options.waitForTimeout;\n\n    return this.browser.wait(function (by, locator, text) {\n      return codeceptjs.findElement(by, locator).innerText.indexOf(text) > -1;\n    }, lctype(locator), lcval(locator), text);\n  }\n\n  /**\n   * {{> ../webapi/waitForVisible }}\n   */\n  waitForVisible(locator, sec) {\n    this.browser.options.waitTimeout = sec * 1000 || this.options.waitForTimeout;\n    locator = guessLocator(locator) || { css: locator};\n\n    return this.browser.wait(function (by, locator) {\n      var el = codeceptjs.findElement(by, locator);\n      if (!el) return false;\n      return el.offsetParent !== null;\n    }, lctype(locator), lcval(locator));\n  }\n\n  /**\n   * {{> ../webapi/waitForElement }}\n   */\n  waitForElement(locator, sec) {\n    this.browser.options.waitTimeout = sec * 1000 || this.options.waitForTimeout;\n    locator = guessLocator(locator) || { css: locator};\n\n    return this.browser.wait(function (by, locator) {\n      return codeceptjs.findElement(by, locator) !== null;\n    }, lctype(locator), lcval(locator));\n  }\n\n  /**\n   * {{> ../webapi/saveScreenshot }}\n   */\n  saveScreenshot(fileName) {\n    let outputFile = path.join(global.output_dir, fileName);\n    this.debug('Screenshot is saving to ' + outputFile);\n    let recorder = require('../recorder');\n    return this.browser.screenshot(outputFile);\n  }\n\n  _failed(test) {\n    let fileName = test.title.replace(/\\W/g, '_') + '.failed.png';\n    return this.saveScreenshot(fileName);\n  }\n\n  /**\n   * Scrolls to element matched by locator.\n   * Extra shift can be set with offsetX and offsetY options\n   *\n   * ```js\n   * I.scrollTo('footer');\n   * I.scrollTo('#submit', 5,5);\n   * ```\n   */\n  scrollTo(locator, offsetX, offsetY) {\n    locator = guessLocator(locator) || {css: locator};\n    return this.browser.evaluate(function (by, locator, offsetX, offsetY) {\n      let el = codeceptjs.findElement(by, locator);\n      if (!el) throw new Error(`Element not found ${by}: ${locator}`);\n      let rect = el.getBoundingClientRect();\n      window.scrollTo(rect.left + offsetX, rect.top + offsetY);\n    }, lctype(locator), lcval(locator), offsetX, offsetY);\n  }\n\n}\n\nmodule.exports = Nightmare;\n\nfunction proceedSee(assertType, text, context) {\n  let description, locator;\n  if (!context) {\n    locator = guessLocator(this.context) || {css: this.context};\n    if (this.context === this.options.rootElement) {\n      description = 'web application';\n    } else {\n      description = 'current context ' + this.context; [];\n    }\n  } else {\n    locator = guessLocator(context) || {css: context};\n    description = 'element ' + context;\n  }\n\n  return this.browser.evaluate(function (by, locator) {\n    return codeceptjs.findElements(by, locator).map((el) => el.innerText);\n  }, lctype(locator), lcval(locator)).then(function (texts) {\n    let allText = texts.join(' | ');\n    return stringIncludes(description)[assertType](text, allText);\n  });\n}\n\nfunction *proceedSeeInField(assertType, field, value) {\n  let els = yield co(findFields(this.browser, field));\n  if (!els.length) {\n    throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n  }\n  let el = els[0];\n  let tag = yield this.browser.evaluate(function (el) {\n    return codeceptjs.fetchElement(el).tagName;\n  }, el);\n  let fieldVal = yield this.browser.evaluate(function (el) {\n    return codeceptjs.fetchElement(el).value;\n  }\n  , el);\n  if (tag == 'select') {\n    // locate option by values and check them\n    let text = yield this.browser.evaluate(function (el, val) {\n      return el.querySelector(`option[value=\"${val}\"]`).innerText;\n    }, el, xpathLocator.literal(fieldVal));\n    return equals('select option by ' + field)[assertType](value, text);\n  }\n  return stringIncludes('field by ' + field)[assertType](value, fieldVal);\n}\n\nfunction *proceedIsChecked(assertType, option) {\n  let els = yield co(findCheckable.call(this, option));\n  if (!els.length) {\n    throw new Error(`Option ${option} not found by name|text|CSS|XPath`);\n  }\n  let selected = yield this.browser.evaluate(function (els) {\n    return els.map((el) => codeceptjs.fetchElement(el).checked)\n      .reduce((prev, cur) => prev || cur);\n  }, els);\n\n  return truth(`checkable ${option}`, 'to be checked')[assertType](selected);\n}\n\n\nfunction *findCheckable(locator, context) {\n  let contextEl = null;\n  if (context) {\n    contextEl = yield this.browser.findElement(context);\n  }\n\n  let matchedLocator = guessLocator(locator);\n  if (matchedLocator) {\n    return this.browser.findElements(matchedLocator, contextEl);\n  }\n\n  let literal = xpathLocator.literal(locator);\n  let byText = xpathLocator.combine([\n    `.//input[@type = 'checkbox' or @type = 'radio'][(@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or @placeholder = ${literal}]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//input[@type = 'radio' or @type = 'checkbox']`\n  ]);\n  let els = yield this.browser.findElements({ xpath: byText}, contextEl);\n  if (els.length) {\n    return els;\n  }\n  let byName = `.//input[@type = 'checkbox' or @type = 'radio'][@name = ${literal}]`;\n  els = yield this.browser.findElements({ xpath: byName}, contextEl);\n  if (els.length) {\n    return els;\n  }\n  return yield this.browser.findElements({ css: locator}, contextEl);\n}\n\nfunction *findClickable(locator, context) {\n  let contextEl = null;\n  if (context) {\n    contextEl = yield this.browser.findElement(context);\n  }\n\n  let l = guessLocator(locator);\n  if (guessLocator(locator)) {\n    return this.browser.findElement(l, contextEl);\n  }\n\n  let literal = xpathLocator.literal(locator);\n\n  let narrowLocator = xpathLocator.combine([\n    `.//a[normalize-space(.)=${literal}]`,\n    `.//button[normalize-space(.)=${literal}]`,\n    `.//a/img[normalize-space(@alt)=${literal}]/ancestor::a`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][normalize-space(@value)=${literal}]`\n  ]);\n  let els = yield this.browser.findElements({xpath: narrowLocator}, contextEl);\n  if (els.length) {\n    return els[0];\n  }\n\n  let wideLocator = xpathLocator.combine([\n    `.//a[./@href][((contains(normalize-space(string(.)), ${literal})) or .//img[contains(./@alt, ${literal})])]`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][contains(./@value, ${literal})]`,\n    `.//input[./@type = 'image'][contains(./@alt, ${literal})]`,\n    `.//button[contains(normalize-space(string(.)), ${literal})]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][./@name = ${literal}]`,\n    `.//button[./@name = ${literal} or ./@title=${literal}]`,\n  ]);\n\n  els = yield this.browser.findElements({xpath: wideLocator}, contextEl);\n  if (els.length) {\n    return els[0];\n  }\n\n  if (isXPath(locator)) {\n    return this.browser.findElement({xpath: locator}, contextEl);\n  }\n  return this.browser.findElement({css: locator}, contextEl);\n}\n\nfunction *findFields(client, locator) {\n  let matchedLocator = guessLocator(locator);\n  if (matchedLocator) {\n    return client.findElements(matchedLocator);\n  }\n  let literal = xpathLocator.literal(locator);\n\n  let byLabelEquals = xpathLocator.combine([\n    `.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')][((./@name = ${literal}) or ./@id = //label[normalize-space(string(.)) = ${literal}]/@for or ./@placeholder = ${literal})]`,\n    `.//label[normalize-space(string(.)) = ${literal}]//.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')]`\n  ]);\n  let els = yield client.findElements({ xpath: byLabelEquals});\n  if (els.length) {\n    return els;\n  }\n\n  let byLabelContains = xpathLocator.combine([\n    `.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')][(((./@name = ${literal}) or ./@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or ./@placeholder = ${literal})]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')]`\n  ]);\n  els = yield client.findElements({ xpath: byLabelContains});\n  if (els.length) {\n    return els;\n  }\n  let byName = `.//*[self::input | self::textarea | self::select][@name = ${literal}]`;\n  els = yield client.findElements({ xpath: byName});\n  if (els.length) {\n    return els;\n  }\n  return yield client.findElements({ css: locator});\n}\n\n\nfunction guessLocator(locator) {\n  if (typeof locator === 'object') {\n    let key = Object.keys(locator)[0];\n    let value = locator[key];\n    locator.toString = () => `{${key}: '${value}'}`;\n    return locator;\n  }\n  if (isCSS(locator)) {\n    return { css: locator };\n  }\n  if (isXPath(locator)) {\n    return { xpath: locator };\n  }\n}\n\nfunction isCSS(locator) {\n  return locator[0] === '#' || locator[0] === '.';\n}\n\nfunction isXPath(locator) {\n  return locator.substr(0, 2) === '//' || locator.substr(0, 3) === './/';\n}\n\nfunction lctype(locator) {\n  return Object.keys(locator)[0];\n}\n\nfunction lcval(locator) {\n  return locator[Object.keys(locator)[0]];\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper/Protractor.js":"'use strict';\nlet By, EC, Runner;\n\nconst requireg = require('requireg');\nconst SeleniumWebdriver = require('./SeleniumWebdriver');\nconst stringIncludes = require('../assert/include').includes;\nconst urlEquals = require('../assert/equal').urlEquals;\nconst equals = require('../assert/equal').equals;\nconst empty = require('../assert/empty').empty;\nconst truth = require('../assert/truth').truth;\nconst xpathLocator = require('../utils').xpathLocator;\nconst fileExists = require('../utils').fileExists;\nconst co = require('co');\nconst path = require('path');\nconst recorder = require('../recorder');\n\nlet withinStore = {};\n\n/**\n * Protractor helper is based on [Protractor library](http://www.protractortest.org) and used for testing AngularJS applications.\n *\n * #### Selenium Installation\n *\n * 1. Download [Selenium Server](http://docs.seleniumhq.org/download/)\n * 2. For Chrome browser install [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/getting-started), for Firefox browser install [GeckoDriver](https://github.com/mozilla/geckodriver).\n * 3. Launch the server: `java -jar selenium-server-standalone-3.xx.xxx.jar`. To locate Chromedriver binary use `-Dwebdriver.chrome.driver=./chromedriver` option. For Geckodriver use `-Dwebdriver.gecko.driver=`.\n *\n * #### PhantomJS Installation\n *\n * PhantomJS is a headless alternative to Selenium Server that implements the WebDriver protocol.\n * It allows you to run Selenium tests on a server without a GUI installed.\n *\n * 1. Download [PhantomJS](http://phantomjs.org/download.html)\n * 2. Run PhantomJS in WebDriver mode: `phantomjs --webdriver=4444`\n *\n * ### Configuration\n *\n * This helper should be configured in codecept.json\n *\n * * `url` - base url of website to be tested\n * * `browser` - browser in which perform testing\n * * `driver` - which protrator driver to use (local, direct, session, hosted, sauce, browserstack). By default set to 'hosted' which requires selenium server to be started.\n * * `restart` (optional, default: true) - restart browser between tests.\n * * `seleniumAddress` - Selenium address to connect (default: http://localhost:4444/wd/hub)\n * * `rootElement` - Root element of AngularJS application (default: body)\n * * `waitForTimeout`: (optional) sets default wait time in _ms_ for all `wait*` functions. 1000 by default.\n * * `scriptsTimeout`: (optional) timeout in milliseconds for each script run on the browser, 10000 by default.\n * * `windowSize`: (optional) default window size. Set to `maximize` or a dimension in the format `640x480`.\n * * `manualStart` (optional, default: false) - do not start browser before a test, start it manually inside a helper with `this.helpers[\"WebDriverIO\"]._startBrowser()`\n * * `capabilities`: {} - list of [Desired Capabilities](https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities)\n * * `proxy`: set proxy settings\n *\n * other options are the same as in [Protractor config](https://github.com/angular/protractor/blob/master/docs/referenceConf.js).\n *\n * ## Access From Helpers\n *\n * Receive a WebDriverIO client from a custom helper by accessing `browser` property:\n *\n * ```js\n * this.helpers['Protractor'].browser\n * ```\n */\nclass Protractor extends SeleniumWebdriver {\n\n  constructor(config) {\n    super(config);\n    this.options = {\n      browser: 'chrome',\n      url: 'http://localhost',\n      seleniumAddress: 'http://localhost:4444/wd/hub',\n      rootElement: 'body',\n      scriptsTimeout: 10000,\n      waitForTimeout: 1000, // ms\n      windowSize: null,\n      driver: 'hosted',\n      capabilities: {}\n    };\n\n\n    this.options = Object.assign(this.options, config);\n    if (!this.options.allScriptsTimeout) this.options.allScriptsTimeout = this.options.scriptsTimeout;\n    if (this.options.proxy) this.options.capabilities.proxy = this.options.proxy;\n    if (this.options.browser) this.options.capabilities.browserName = this.options.browser;\n    this.options.waitForTimeout /= 1000; // convert to seconds\n  }\n\n  _init() {\n    Runner = requireg('protractor/built/runner').Runner;\n    By = requireg('protractor').ProtractorBy;\n    this.isProtractor5 = !requireg('protractor').wrapDriver;\n\n    try {\n      // get selenium-webdriver\n      this.webdriver = requireg('selenium-webdriver');\n    } catch (e) {\n       // maybe it is installed as protractor dependency?\n      this.webdriver = requireg('protractor/node_modules/selenium-webdriver');\n    }\n  }\n\n  static _checkRequirements() {\n    try {\n      requireg(\"protractor\");\n      require('assert').ok(requireg(\"protractor/built/runner\").Runner);\n    } catch(e) {\n      return [\"protractor@^5.0.0\"];\n    }\n  }\n\n  static _config() {\n    return [\n      { name: 'url', message: \"Base url of site to be tested\", default: 'http://localhost' },\n      { name: 'driver', message: \"Protractor driver (local, direct, session, hosted, sauce, browserstack)\", default: 'hosted' },\n      { name: 'browser', message: 'Browser in which testing will be performed', default: 'chrome' },\n      { name: 'rootElement', message: \"Root element of AngularJS application\", default: 'body' },\n    ];\n  }\n\n  _startBrowser() {\n    let runner = new Runner(this.options);\n    this.browser = runner.createBrowser();\n\n    global.browser = this.browser;\n    global.$ = this.browser.$;\n    global.$$ = this.browser.$$;\n    global.element = this.browser.element;\n    global.by = global.By = new By();\n    global.ExpectedConditions = EC = this.browser.ExpectedConditions;\n\n    if (this.options.windowSize == 'maximize') {\n      this.resizeWindow(this.options.windowSize);\n    }\n\n    if (this.options.windowSize) {\n      var size = this.options.windowSize.split('x');\n      this.resizeWindow(parseInt(size[0]), parseInt(size[1]));\n    }\n\n    return this.browser;\n  }\n\n  _before() {\n    super._before();\n    this.amInsideAngularApp();\n    this.context = this.options.rootElement;\n    return this.browser;\n  }\n\n  _withinBegin(locator) {\n    withinStore.elFn = this.browser.findElement;\n    withinStore.elsFn = this.browser.findElements;\n\n    this.context = locator;\n    if (this.insideAngular) {\n      let context = element(guessLocator(locator) || by.css(locator));\n\n      this.browser.findElement = (l) => l ? context.element(l).getWebElement() : context.getWebElement();\n      this.browser.findElements = (l) => context.all(l).getWebElements();\n      return context;\n    }\n    return super._withinBegin(locator);\n  }\n\n  _withinEnd() {\n    this.browser.findElement = withinStore.elFn;\n    this.browser.findElements = withinStore.elsFn;\n    this.context = this.options.rootElement;\n  }\n\n  /**\n   * Get elements by different locator types, including strict locator\n   * Should be used in custom helpers:\n   *\n   * ```js\n   * this.helpers['Protractor']._locate({model: 'newTodo'}).then //...\n   * ```\n   */\n  _locate(locator) {\n    return this.browser.findElements(guessLocator(locator));\n  }\n\n  /**\n   * Switch to non-Angular mode,\n   * start using WebDriver instead of Protractor in this session\n   */\n  amOutsideAngularApp() {\n    if (!this.browser) return;\n    this.browser.ignoreSynchronization = true;\n    return Promise.resolve(this.insideAngular = false);\n  }\n\n  /**\n   * Enters Angular mode (switched on by default)\n   * Should be used after \"amOutsideAngularApp\"\n   */\n  amInsideAngularApp() {\n    if (this.browser.driver && this.insideAngular) {\n      return; // already inside angular\n    }\n    this.browser.ignoreSynchronization = false;\n    return Promise.resolve(this.insideAngular = true);\n  }\n\n  /**\n   * {{> ../webapi/waitForElement }}\n   */\n  waitForElement(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = element(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(EC.presenceOf(el), sec * 1000);\n  }\n\n  /**\n   * Waits for element to become clickable for number of seconds.\n   */\n  waitForClickable(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = element(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(EC.elementToBeClickable(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForVisible }}\n   */\n  waitForVisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = element(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(EC.visibilityOf(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForInvisible }}\n   */\n  waitForInvisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = element(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(EC.invisibilityOf(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForStalenessOf }}\n   */\n  waitForStalenessOf(locator, sec) {\n    return this.waitForInvisible(locator, sec);\n  }\n\n  /**\n   * {{> ../webapi/waitForText }}\n   */\n  waitForText(text, sec, context) {\n    if (!context) {\n      context = this.context;\n    }\n    let el = element(guessLocator(context) || by.css(context));\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.wait(EC.textToBePresentInElement(el, text), sec * 1000);\n  }\n\n  // ANGULAR SPECIFIC\n\n  /**\n   * Moves to url\n   */\n  moveTo(path) {\n    return this.browser.setLocation(path);\n  }\n\n  /**\n   * Reloads page\n   */\n  refresh() {\n    return this.browser.refresh();\n  }\n\n  /**\n   * Injects Angular module.\n   *\n   * ```js\n   * I.haveModule('modName', function() {\n   *   angular.module('modName', []).value('foo', 'bar');\n   * });\n   * ```\n   */\n  haveModule(modName, fn) {\n    return this.browser.addMockModule(modName, fn);\n  }\n\n  /**\n   * Removes mocked Angular module. If modName not specified - clears all mock modules.\n   *\n   * ```js\n   * I.resetModule(); // clears all\n   * I.resetModule('modName');\n   * ```\n   */\n  resetModule(modName) {\n    if (!modName) {\n      return this.browser.clearMockModules();\n    }\n    return this.browser.removeMockModule(modName);\n  }\n\n  setCookie(cookie) {\n    if (this.isProtractor5) {\n      return this.browser.manage().addCookie(cookie);\n    }\n    return super.setCookie(cookie);\n  }\n}\n\nmodule.exports = Protractor;\n\nfunction guessLocator(locator) {\n  if (!locator) {\n    return;\n  }\n  if (typeof locator === 'object') {\n    let key = Object.keys(locator)[0];\n    let value = locator[key];\n    return by[key](value);\n  }\n  if (isCSS(locator)) {\n    return by.css(locator);\n  }\n  if (isXPath(locator)) {\n    return by.xpath(locator);\n  }\n}\n\nfunction isCSS(locator) {\n  return locator[0] === '#' || locator[0] === '.';\n}\n\nfunction isXPath(locator) {\n  return locator.substr(0, 2) === '//' || locator.substr(0, 3) === './/';\n}\n\n// docs for inherited methods\n\n/**\n * {{> ../webapi/amOnPage }}\n *\n * @name amOnPage\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _amOnPage;\n\n/**\n * {{> ../webapi/appendField }}\n *\n * @name appendField\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _appendField;\n\n/**\n * {{> ../webapi/attachFile }}\n *\n * @name attachFile\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _attachFile;\n\n/**\n * {{> ../webapi/checkOption }}\n *\n * @name checkOption\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _checkOption;\n\n/**\n * {{> ../webapi/clearCookie }}\n *\n * @name clearCookie\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _clearCookie;\n\n/**\n * {{> ../webapi/click }}\n *\n * @name click\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _click;\n\n/**\n * {{> ../webapi/dontSeeCheckboxIsChecked }}\n *\n * @name dontSeeCheckboxIsChecked\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeCheckboxIsChecked;\n\n/**\n * {{> ../webapi/dontSeeCookie }}\n *\n * @name dontSeeCookie\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeCookie;\n\n/**\n * {{> ../webapi/dontSeeCurrentUrlEquals }}\n *\n * @name dontSeeCurrentUrlEquals\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeCurrentUrlEquals;\n\n/**\n * {{> ../webapi/dontSeeElement }}\n *\n * @name dontSeeElement\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeElement;\n\n/**\n * {{> ../webapi/dontSeeInCurrentUrl }}\n *\n * @name dontSeeInCurrentUrl\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeInCurrentUrl;\n\n/**\n * {{> ../webapi/dontSeeInField }}\n *\n * @name dontSeeInField\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeInField;\n\n/**\n * {{> ../webapi/dontSeeInSource }}\n *\n * @name dontSeeInSource\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeInSource;\n\n/**\n * {{> ../webapi/dontSeeInTitle }}\n *\n * @name dontSeeInTitle\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSeeInTitle;\n\n/**\n * {{> ../webapi/dontSee }}\n *\n * @name dontSee\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _dontSee;\n\n/**\n * {{> ../webapi/executeAsyncScript }}\n *\n * @name executeAsyncScript\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _executeAsyncScript;\n\n/**\n * {{> ../webapi/executeScript }}\n *\n * @name executeScript\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _executeScript;\n\n/**\n * {{> ../webapi/fillField }}\n *\n * @name fillField\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _fillField;\n\n/**\n * {{> ../webapi/grabAttributeFrom }}\n *\n * @name grabAttributeFrom\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _grabAttributeFrom;\n\n/**\n * {{> ../webapi/grabCookie }}\n *\n * @name grabCookie\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _grabCookie;\n\n/**\n * {{> ../webapi/grabTextFrom }}\n *\n * @name grabTextFrom\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _grabTextFrom;\n\n/**\n * {{> ../webapi/grabTitle }}\n *\n * @name grabTitle\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _grabTitle;\n\n/**\n * {{> ../webapi/grabValueFrom }}\n *\n * @name grabValueFrom\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _grabValueFrom;\n\n/**\n * {{> ../webapi/pressKey }}\n *\n * @name pressKey\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _pressKey;\n\n/**\n * {{> ../webapi/resizeWindow }}\n *\n * @name resizeWindow\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _resizeWindow;\n\n/**\n * {{> ../webapi/saveScreenshot }}\n *\n * @name saveScreenshot\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _saveScreenshot;\n\n/**\n * {{> ../webapi/seeCheckboxIsChecked }}\n *\n * @name seeCheckboxIsChecked\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeCheckboxIsChecked;\n\n/**\n * {{> ../webapi/seeCookie }}\n *\n * @name seeCookie\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeCookie;\n\n/**\n * {{> ../webapi/seeCurrentUrlEquals }}\n *\n * @name seeCurrentUrlEquals\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeCurrentUrlEquals;\n\n/**\n * {{> ../webapi/seeElement }}\n *\n * @name seeElement\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeElement;\n\n/**\n * {{> ../webapi/seeInCurrentUrl }}\n *\n * @name seeInCurrentUrl\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeInCurrentUrl;\n\n/**\n * {{> ../webapi/seeInField }}\n *\n * @name seeInField\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeInField;\n\n/**\n * {{> ../webapi/seeInSource }}\n *\n * @name seeInSource\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeInSource;\n\n/**\n * {{> ../webapi/seeInTitle }}\n *\n * @name seeInTitle\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _seeInTitle;\n\n/**\n * {{> ../webapi/see }}\n *\n * @name see\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _see;\n\n/**\n * {{> ../webapi/selectOption }}\n *\n * @name selectOption\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _selectOption;\n\n/**\n * {{> ../webapi/setCookie }}\n *\n * @name setCookie\n * @kind function\n * @memberof Protractor\n * @scope instance\n */\nvar _setCookie;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper/SeleniumWebdriver.js":"'use strict';\nlet until;\n\nconst requireg = require('requireg');\nconst Helper = require('../helper');\nconst stringIncludes = require('../assert/include').includes;\nconst urlEquals = require('../assert/equal').urlEquals;\nconst equals = require('../assert/equal').equals;\nconst empty = require('../assert/empty').empty;\nconst truth = require('../assert/truth').truth;\nconst xpathLocator = require('../utils').xpathLocator;\nconst fileExists = require('../utils').fileExists;\nconst co = require('co');\nconst path = require('path');\nconst recorder = require('../recorder');\n\nlet withinStore = {};\n\n/**\n * SeleniumWebdriver helper is based on the official [Selenium Webdriver JS](https://www.npmjs.com/package/selenium-webdriver)\n * library. It implements common web api methods (amOnPage, click, see).\n *\n * #### Selenium Installation\n *\n * 1. Download [Selenium Server](http://docs.seleniumhq.org/download/)\n * 2. For Chrome browser install [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/getting-started), for Firefox browser install [GeckoDriver](https://github.com/mozilla/geckodriver).\n * 3. Launch the server: `java -jar selenium-server-standalone-3.xx.xxx.jar`. To locate Chromedriver binary use `-Dwebdriver.chrome.driver=./chromedriver` option. For Geckodriver use `-Dwebdriver.gecko.driver=`.\n *\n *\n * #### PhantomJS Installation\n *\n * PhantomJS is a headless alternative to Selenium Server that implements [the WebDriver protocol](https://code.google.com/p/selenium/wiki/JsonWireProtocol).\n * It allows you to run Selenium tests on a server without a GUI installed.\n *\n * 1. Download [PhantomJS](http://phantomjs.org/download.html)\n * 2. Run PhantomJS in WebDriver mode: `phantomjs --webdriver=4444`\n *\n * ### Configuration\n *\n * This helper should be configured in codecept.json\n *\n * * `url` - base url of website to be tested\n * * `browser` - browser in which perform testing\n * * `driver` - which protrator driver to use (local, direct, session, hosted, sauce, browserstack). By default set to 'hosted' which requires selenium server to be started.\n * * `restart` - restart browser between tests (default: true).\n * * `keepCookies` (optional, default: false)  - keep cookies between tests when `restart` set to false.*\n * * `seleniumAddress` - Selenium address to connect (default: http://localhost:4444/wd/hub)\n * * `waitForTimeout`: (optional) sets default wait time in _ms_ for all `wait*` functions. 1000 by default;\n * * `scriptTimeout`: (optional) sets default timeout for scripts in `executeAsync`. 1000 by default.\n * * `windowSize`: (optional) default window size. Set to `maximize` or a dimension in the format `640x480`.\n * * `manualStart` (optional, default: false) - do not start browser before a test, start it manually inside a helper with `this.helpers[\"WebDriverIO\"]._startBrowser()`\n * * `capabilities`: {} - list of [Desired Capabilities](https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities)\n *\n * ## Access From Helpers\n *\n * Receive a WebDriverIO client from a custom helper by accessing `browser` property:\n *\n * ```js\n * this.helpers['SeleniumWebdriver'].browser\n * ```\n *\n */\nclass SeleniumWebdriver extends Helper {\n\n  constructor(config) {\n    super(config);\n\n    this.options = {\n      browser: 'firefox',\n      url: 'http://localhost',\n      seleniumAddress: 'http://localhost:4444/wd/hub',\n      restart: true,\n      keepCookies: false,\n      windowSize: null,\n      waitForTimeout: 1000, // ms\n      scriptTimeout: 1000, // ms\n      manualStart: false,\n      capabilities: {}\n    };\n    if (this.options.waitforTimeout) {\n      console.log(`waitforTimeout is deprecated in favor of waitForTimeout, please update config`);\n      this.options.waitForTimeout = this.options.waitforTimeout;\n    }\n    this.options = Object.assign(this.options, config);\n    this.options.waitForTimeout /= 1000; // convert to seconds\n  }\n\n  _init() {\n    this.webdriver = requireg('selenium-webdriver');\n    global.by = this.webdriver.By;\n\n    this.context = 'body';\n    this.options.rootElement = 'body'; // protractor compat\n\n    this.browserBuilder = new this.webdriver.Builder()\n      .withCapabilities(this.options.capabilities)\n      .forBrowser(this.options.browser)\n      .usingServer(this.options.seleniumAddress);\n\n    if (this.options.proxy) this.browserBuilder.setProxy(this.options.proxy);\n  }\n\n  static _checkRequirements() {\n    try {\n      requireg(\"selenium-webdriver\");\n    } catch(e) {\n      return [\"selenium-webdriver\"];\n    }\n  }\n\n  static _config() {\n    return [\n      { name: 'url', message: \"Base url of site to be tested\", default: 'http://localhost' },\n      { name: 'browser', message: 'Browser in which testing will be performed', default: 'chrome' },\n    ];\n  }\n\n  _startBrowser() {\n    this.browser = this.browserBuilder.build();\n\n    if (this.options.windowSize == 'maximize') {\n      this.resizeWindow(this.options.windowSize);\n    }\n\n    if (this.options.windowSize) {\n      var size = this.options.windowSize.split('x');\n      this.resizeWindow(parseInt(size[0]), parseInt(size[1]));\n    }\n\n    return this.browser;\n  }\n\n  _beforeSuite() {\n    if (!this.options.restart && !this.options.manualStart) {\n      this.debugSection('Session', 'Starting singleton browser session');\n      return this._startBrowser();\n    }\n  }\n\n  _before() {\n    if (this.options.restart && !this.options.manualStart) {\n      return this._startBrowser();\n    }\n  }\n\n  _after() {\n    if (this.options.restart) return this.browser.quit();\n    if (this.options.keepCookies) return;\n    // if browser should not be restarted\n    this.debugSection('Session', 'cleaning cookies and localStorage');\n    return this.browser.executeScript('localStorage.clear();').then(() => {\n      return this.browser.manage().deleteAllCookies();\n    });\n  }\n\n  _afterSuite() {\n    if (!this.options.restart) return this.browser.quit();\n  }\n\n  _failed(test) {\n    let fileName = test.title.replace(/ /g, '_') + '.failed.png';\n    return this.saveScreenshot(fileName);\n  }\n\n  _withinBegin(locator) {\n    withinStore.elFn = this.browser.findElement;\n    withinStore.elsFn = this.browser.findElements;\n\n    this.context = locator;\n    let context = this.browser.findElement(guessLocator(locator) || by.css(locator));\n\n    this.browser.findElement = (l) => context.findElement(l);\n    this.browser.findElements = (l) => context.findElements(l);\n    return context;\n  }\n\n  _withinEnd() {\n    this.browser.findElement = withinStore.elFn;\n    this.browser.findElements = withinStore.elsFn;\n    this.context = this.options.rootElement;\n  }\n\n  /**\n   * Get elements by different locator types, including strict locator\n   * Should be used in custom helpers:\n   *\n   * ```js\n   * this.helpers['SeleniumWebdriver']._locate({name: 'password'}).then //...\n   * ```\n   */\n  _locate(locator) {\n    return this.browser.findElements(guessLocator(locator));\n  }\n\n  /**\n   * {{> ../webapi/amOnPage }}\n   */\n  amOnPage(url) {\n    if (url.indexOf('http') !== 0) {\n      url = this.options.url + url;\n    }\n    return this.browser.get(url);\n  }\n\n  /**\n   * {{> ../webapi/click }}\n   */\n  click(locator, context) {\n    let matcher = this.browser;\n    if (context) {\n      matcher = matcher.findElement(guessLocator(context) || by.css(context));\n    }\n    return co(findClickable(matcher, locator)).then((el) => el.click());\n  }\n\n  /**\n   * {{> ../webapi/doubleClick }}\n   */\n  doubleClick(locator, context) {\n    let matcher = this.browser;\n    if (context) {\n      matcher = matcher.findElement(guessLocator(context) || by.css(context));\n    }\n    return co(findClickable(matcher, locator)).then((el) => this.browser.actions().doubleClick(el).perform());\n  }\n\n  /**\n   * {{> ../webapi/moveCursorTo}}\n   */\n  moveCursorTo(locator, offsetX, offsetY) {\n    let offset = null;\n    if (offsetX !== null || offsetY !== null) {\n      offset = {x: offsetX, y: offsetY};\n    }\n    return this.browser.findElement(guessLocator(locator) || by.css(locator)).then((el) => {\n      return this.browser.actions().mouseMove(el, offset).perform();\n    });\n  }\n\n  /**\n   * {{> ../webapi/see }}\n   */\n  see(text, context) {\n    return proceedSee.call(this, 'assert', text, context);\n  }\n\n  /**\n   * {{> ../webapi/dontSee }}\n   */\n  dontSee(text, context) {\n    return proceedSee.call(this, 'negate', text, context);\n  }\n\n  /**\n   * {{> ../webapi/selectOption }}\n   */\n  selectOption(select, option) {\n    return co(findFields(this.browser, select)).then(co.wrap(function*(fields) {\n      if (!fields.length) {\n        throw new Error(`Selectable field ${select} not found by name|text|CSS|XPath`);\n      }\n      if (!Array.isArray(option)) {\n        option = [option];\n      }\n      let field = fields[0];\n      let promises = [];\n      for (let key in option) {\n        let opt = option[key];\n        let normalizedText = `[normalize-space(.) = \"${opt.trim() }\"]`;\n        let byVisibleText = `./option${normalizedText}|./optgroup/option${normalizedText}`;\n        let els = yield field.findElements(by.xpath(byVisibleText));\n        if (!els.length) {\n          let normalizedValue = `[normalize-space(@value) = \"${opt.trim() }\"]`;\n          let byValue = `./option${normalizedValue}|./optgroup/option${normalizedValue}`;\n          els = yield field.findElements(by.xpath(byValue));\n        }\n        els.forEach((el) => promises.push(el.click()));\n      }\n      return Promise.all(promises);\n    }));\n  }\n\n  /**\n   * {{> ../webapi/fillField }}\n   */\n  fillField(field, value) {\n    return co(findFields(this.browser, field)).then(co.wrap(function*(els) {\n      if (!els.length) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      yield els[0].clear();\n      return els[0].sendKeys(value);\n    }));\n  }\n\n  /**\n   * {{> ../webapi/pressKey }}\n   */\n  pressKey(key) {\n    let modifier;\n    if (Array.isArray(key) && ~['Control', 'Command', 'Shift', 'Alt'].indexOf(key[0])) {\n      modifier = this.webdriver.Key[key[0].toUpperCase()];\n      key = key[1];\n    }\n\n    // guess special key in Selenium Webdriver list\n    if (this.webdriver.Key[key.toUpperCase()]) {\n      key = this.webdriver.Key[key.toUpperCase()];\n    }\n\n    let action = new this.webdriver.ActionSequence(this.browser);\n    if (modifier) action.keyDown(modifier);\n    action.sendKeys(key);\n    if (modifier) action.keyUp(modifier);\n    return action.perform();\n  }\n\n  /**\n   * {{> ../webapi/attachFile }}\n   */\n  attachFile(locator, pathToFile) {\n    let file = path.join(global.codecept_dir, pathToFile);\n    if (!fileExists(file)) {\n      throw new Error(`File at ${file} can not be found on local system`);\n    }\n    return co(findFields(this.browser, locator)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Field ${locator} not found by name|text|CSS|XPath`);\n      }\n      if (this.options.browser !== 'phantomjs') {\n        var remote = require('selenium-webdriver/remote');\n        this.browser.setFileDetector(new remote.FileDetector());\n      }\n      return els[0].sendKeys(file);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInField }}\n   */\n  seeInField(field, value) {\n    return co.wrap(proceedSeeInField).call(this, 'assert', field, value);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInField }}\n   */\n  dontSeeInField(field, value) {\n    return co.wrap(proceedSeeInField).call(this, 'negate', field, value);\n  }\n\n  /**\n   * {{> ../webapi/appendField }}\n   */\n  appendField(field, value) {\n    return co(findFields(this.browser, field)).then(co.wrap(function*(els) {\n      if (!els.length) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      return els[0].sendKeys(value);\n    }));\n  }\n\n  /**\n   * {{> ../webapi/clearField }}\n   */\n  clearField(field, value) {\n    return co(findFields(this.browser, field)).then(co.wrap(function*(els) {\n      if (!els.length) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      return els[0].clear();\n    }));\n  }\n\n  /**\n   * {{> ../webapi/checkOption }}\n   */\n  checkOption(field, context) {\n    let matcher = this.browser;\n    if (context) {\n      matcher = matcher.findElement(guessLocator(context) || by.css(context));\n    }\n    return co(findCheckable(matcher, field)).then((els) => {\n      if (!els.length) {\n        throw new Error(`Option ${field} not found by name|text|CSS|XPath`);\n      }\n      return els[0].isSelected().then((selected) => {\n        if (!selected) return els[0].click();\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeCheckboxIsChecked }}\n   */\n  seeCheckboxIsChecked(field) {\n    return co.wrap(proceedIsChecked).call(this, 'assert', field);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCheckboxIsChecked }}\n   */\n  dontSeeCheckboxIsChecked(field) {\n    return co.wrap(proceedIsChecked).call(this, 'negate', field);\n  }\n\n  /**\n   * {{> ../webapi/grabTextFrom }}\n   */\n  grabTextFrom(locator) {\n    return this.browser.findElement(guessLocator(locator) || by.css(locator)).getText();\n  }\n\n  /**\n   * {{> ../webapi/grabValueFrom }}\n   */\n  grabValueFrom(locator) {\n    return co(findFields(this.browser, locator)).then(function (els) {\n      if (!els.length) {\n        throw new Error(`Field ${locator} was not located by name|label|CSS|XPath`);\n      }\n      return els[0].getAttribute('value');\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabAttributeFrom }}\n   */\n  grabAttributeFrom(locator, attr) {\n    return this.browser.findElement(guessLocator(locator) || by.css(locator)).getAttribute(attr);\n  }\n\n  /**\n   * {{> ../webapi/seeInTitle }}\n   */\n  seeInTitle(text) {\n    return this.browser.getTitle().then((title) => {\n      return stringIncludes('web page title').assert(text, title);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInTitle }}\n   */\n  dontSeeInTitle(text) {\n    return this.browser.getTitle().then((title) => {\n      return stringIncludes('web page title').negate(text, title);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabTitle }}\n   */\n  grabTitle() {\n    return this.browser.getTitle().then((title) => {\n      this.debugSection('Title', title);\n      return title;\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeElement }}\n   */\n  seeElement(locator) {\n    return this.browser.findElements(guessLocator(locator) || by.css(locator)).then((els) => {\n      return Promise.all(els.map((el) => el.isDisplayed())).then((els) => {\n        return empty('elements').negate(els.filter((v) => v).fill('ELEMENT'));\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElement }}\n   */\n  dontSeeElement(locator) {\n    return this.browser.findElements(guessLocator(locator) || by.css(locator)).then((els) => {\n      return Promise.all(els.map((el) => el.isDisplayed())).then((els) => {\n        return empty('elements').assert(els.filter((v) => v).fill('ELEMENT'));\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeElementInDOM }}\n   */\n  seeElementInDOM(locator) {\n    return this.browser.findElements(guessLocator(locator) || by.css(locator)).then((els) => {\n      return empty('elements').negate(els.fill('ELEMENT'));\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElementInDOM }}\n   */\n  dontSeeElementInDOM(locator) {\n    return this.browser.findElements(guessLocator(locator) || by.css(locator)).then((els) => {\n      return empty('elements').assert(els.fill('ELEMENT'));\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInSource }}\n   */\n  seeInSource(text) {\n    return this.browser.getPageSource().then((source) => {\n      return stringIncludes('HTML source of a page').assert(text, source);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInSource }}\n   */\n  dontSeeInSource(text) {\n    return this.browser.getPageSource().then((source) => {\n      return stringIncludes('HTML source of a page').negate(text, source);\n    });\n  }\n\n  /**\n   * {{> ../webapi/executeScript }}\n   */\n  executeScript(fn) {\n    return this.browser.executeScript.apply(this.browser, arguments);\n  }\n\n  /**\n   * {{> ../webapi/executeAsyncScript }}\n   */\n  executeAsyncScript(fn) {\n    this.browser.manage().timeouts().setScriptTimeout(this.options.scriptTimeout);\n    return this.browser.executeAsyncScript.apply(this.browser, arguments);\n  }\n\n  /**\n   * {{> ../webapi/seeInCurrentUrl }}\n   */\n  seeInCurrentUrl(url) {\n    return this.browser.getCurrentUrl().then(function (currentUrl) {\n      return stringIncludes('url').assert(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInCurrentUrl }}\n   */\n  dontSeeInCurrentUrl(url) {\n    return this.browser.getCurrentUrl().then(function (currentUrl) {\n      return stringIncludes('url').negate(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeCurrentUrlEquals }}\n   */\n  seeCurrentUrlEquals(url) {\n    return this.browser.getCurrentUrl().then((currentUrl) => {\n      return urlEquals(this.options.url).assert(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCurrentUrlEquals }}\n   */\n  dontSeeCurrentUrlEquals(url) {\n    return this.browser.getCurrentUrl().then((currentUrl) => {\n      return urlEquals(this.options.url).negate(url, currentUrl);\n    });\n  }\n\n  /**\n   * {{> ../webapi/saveScreenshot }}\n   */\n  saveScreenshot(fileName) {\n    let outputFile = path.join(global.output_dir, fileName);\n    this.debug('Screenshot has been saved to ' + outputFile);\n    return this.browser.takeScreenshot().then(function (png) {\n      let fs = require('fs');\n      var stream = fs.createWriteStream(outputFile);\n      stream.write(new Buffer(png, 'base64'));\n      stream.end();\n      return new Promise(function (resolve) {\n        return stream.on('finish', resolve);\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/setCookie}}\n   *\n   *\n   */\n  setCookie(cookie) {\n    let cookieArray = [];\n    if (cookie.name) cookieArray.push(cookie.name);\n    if (cookie.value) cookieArray.push(cookie.value);\n    if (cookie.path) cookieArray.push(cookie.path);\n    if (cookie.domain) cookieArray.push(cookie.domain);\n    if (cookie.secure) cookieArray.push(cookie.secure);\n    if (cookie.expiry) cookieArray.push(cookie.expiry);\n\n    let manage = this.browser.manage();\n    return manage.addCookie.apply(manage, cookieArray);\n  }\n\n  /**\n   * {{> ../webapi/clearCookie}}\n   */\n  clearCookie(cookie) {\n    if (!cookie) {\n      return this.browser.manage().deleteAllCookies();\n    }\n    return this.browser.manage().deleteCookie(cookie);\n  }\n\n  /**\n   * {{> ../webapi/seeCookie}}\n   */\n  seeCookie(name) {\n    return this.browser.manage().getCookie(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').assert(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCookie}}\n   */\n  dontSeeCookie(name) {\n    return this.browser.manage().getCookie(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').negate(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabCookie}}\n   *\n   * Returns cookie in JSON [format](https://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object).\n   */\n  grabCookie(name) {\n    return this.browser.manage().getCookie(name);\n  }\n\n  /**\n   * {{> ../webapi/resizeWindow }}\n   */\n  resizeWindow(width, height) {\n    if (width === 'maximize') {\n      return this.browser.manage().window().maximize();\n    }\n    return this.browser.manage().window().setSize(width, height);\n  }\n\n  /**\n   * {{> ../webapi/wait }}\n   */\n  wait(sec) {\n    return this.browser.sleep(sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForElement }}\n   */\n  waitForElement(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.wait(this.webdriver.until.elementsLocated(guessLocator(locator) || by.css(locator)), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForVisible }}\n   */\n  waitForVisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = this.browser.findElement(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(this.webdriver.until.elementIsVisible(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForInvisible }}\n   */\n  waitForInvisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = this.browser.findElement(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(this.webdriver.until.elementIsNotVisible(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForStalenessOf }}\n   */\n  waitForStalenessOf(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    let el = this.browser.findElement(guessLocator(locator) || by.css(locator));\n    return this.browser.wait(this.webdriver.until.stalenessOf(el), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForText }}\n   */\n  waitForText(text, sec, context) {\n    if (!context) {\n      context = this.context;\n    }\n    let el = this.browser.findElement(guessLocator(context) || by.css(context));\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.wait(this.webdriver.until.elementTextIs(el, text), sec * 1000);\n  }\n\n}\n\nmodule.exports = SeleniumWebdriver;\n\nfunction *findCheckable(client, locator) {\n  let matchedLocator = guessLocator(locator);\n  if (matchedLocator) {\n    return client.findElements(matchedLocator);\n  }\n  let literal = xpathLocator.literal(locator);\n  let byText = xpathLocator.combine([\n    `.//input[@type = 'checkbox' or @type = 'radio'][(@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or @placeholder = ${literal}]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//input[@type = 'radio' or @type = 'checkbox']`\n  ]);\n  let els = yield client.findElements(by.xpath(byText));\n  if (els.length) {\n    return els;\n  }\n  let byName = `.//input[@type = 'checkbox' or @type = 'radio'][@name = ${literal}]`;\n  els = yield client.findElements(by.xpath(byName));\n  if (els.length) {\n    return els;\n  }\n  return yield client.findElements(by.css(locator));\n}\n\nfunction *findFields(client, locator) {\n  let matchedLocator = guessLocator(locator);\n  if (matchedLocator) {\n    return client.findElements(matchedLocator);\n  }\n  let literal = xpathLocator.literal(locator);\n\n  let byLabelEquals = xpathLocator.combine([\n    `.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')][((./@name = ${literal}) or ./@id = //label[normalize-space(string(.)) = ${literal}]/@for or ./@placeholder = ${literal})]`,\n    `.//label[normalize-space(string(.)) = ${literal}]//.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')]`\n  ]);\n  let els = yield client.findElements(by.xpath(byLabelEquals));\n  if (els.length) {\n    return els;\n  }\n\n  let byLabelContains = xpathLocator.combine([\n    `.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')][(((./@name = ${literal}) or ./@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or ./@placeholder = ${literal})]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')]`\n  ]);\n  els = yield client.findElements(by.xpath(byLabelContains));\n  if (els.length) {\n    return els;\n  }\n  let byName = `.//*[self::input | self::textarea | self::select][@name = ${literal}]`;\n  els = yield client.findElements(by.xpath(byName));\n  if (els.length) {\n    return els;\n  }\n  return yield client.findElements(by.css(locator));\n}\n\nfunction proceedSee(assertType, text, context) {\n  let description, locator;\n  if (!context) {\n    if (this.context === this.options.rootElement) {\n      locator = guessLocator(this.context) || by.css(this.context);\n      description = 'web application';\n    } else {\n      locator = null;\n      description = 'current context ' + this.context;\n    }\n  } else {\n    locator = guessLocator(context) || by.css(context);\n    description = 'element ' + context;\n  }\n  return this.browser.findElements(locator).then(co.wrap(function*(els) {\n    let promises = [];\n    let source = '';\n    els.forEach(el => promises.push(el.getText().then((elText) => source += '| ' + elText)));\n    yield Promise.all(promises);\n    return stringIncludes(description)[assertType](text, source);\n  }));\n}\n\nfunction *proceedSeeInField(assertType, field, value) {\n  let els = yield co(findFields(this.browser, field));\n  if (!els.length) {\n    throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n  }\n  let el = els[0];\n  let tag = yield el.getTagName();\n  let fieldVal = yield el.getAttribute('value');\n  if (tag == 'select') {\n    // locate option by values and check them\n    let text = yield el.findElement(by.xpath(`./option[@value=${xpathLocator.literal(fieldVal)}]`)).getText();\n    return equals('select option by ' + field)[assertType](value, text);\n  }\n  return stringIncludes('field by ' + field)[assertType](value, fieldVal);\n}\n\nfunction *proceedIsChecked(assertType, option) {\n  return co(findCheckable(this.browser, option)).then((els) => {\n    if (!els.length) {\n      throw new Error(`Option ${option} not found by name|text|CSS|XPath`);\n    }\n    let elsSelected = [];\n    els.forEach(function (el) {\n      elsSelected.push(el.isSelected());\n    });\n    return Promise.all(elsSelected).then(function (values) {\n      let selected = values.reduce((prev, cur) => prev || cur);\n      return truth(`checkable ${option}`, 'to be checked')[assertType](selected);\n    });\n  });\n}\n\nfunction *findClickable(matcher, locator) {\n  let l = guessLocator(locator);\n  if (guessLocator(locator)) {\n    return matcher.findElement(l);\n  }\n\n  let literal = xpathLocator.literal(locator);\n\n  let narrowLocator = xpathLocator.combine([\n    `.//a[normalize-space(.)=${literal}]`,\n    `.//button[normalize-space(.)=${literal}]`,\n    `.//a/img[normalize-space(@alt)=${literal}]/ancestor::a`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][normalize-space(@value)=${literal}]`\n  ]);\n  let els = yield matcher.findElements(by.xpath(narrowLocator));\n  if (els.length) {\n    return els[0];\n  }\n\n  let wideLocator = xpathLocator.combine([\n    `.//a[./@href][((contains(normalize-space(string(.)), ${literal})) or .//img[contains(./@alt, ${literal})])]`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][contains(./@value, ${literal})]`,\n    `.//input[./@type = 'image'][contains(./@alt, ${literal})]`,\n    `.//button[contains(normalize-space(string(.)), ${literal})]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][./@name = ${literal}]`,\n    `.//button[./@name = ${literal}]`\n  ]);\n\n  els = yield matcher.findElements(by.xpath(wideLocator));\n  if (els.length) {\n    return els[0];\n  }\n  if (isXPath(locator)) {\n    return matcher.findElement(by.xpath(locator));\n  }\n  return matcher.findElement(by.css(locator));\n}\n\nfunction guessLocator(locator) {\n  if (!locator) {\n    return;\n  }\n  if (typeof locator === 'object') {\n    let key = Object.keys(locator)[0];\n    let value = locator[key];\n    locator.toString = () => `{${key}: '${value}'}`;\n    return by[key](value);\n  }\n  if (isCSS(locator)) {\n    return by.css(locator);\n  }\n  if (isXPath(locator)) {\n    return by.xpath(locator);\n  }\n}\n\nfunction isCSS(locator) {\n  return locator[0] === '#' || locator[0] === '.';\n}\n\nfunction isXPath(locator) {\n  return locator.substr(0, 2) === '//' || locator.substr(0, 3) === './/';\n}\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/helper/WebDriverIO.js":"'use strict';\nlet webdriverio;\nconst Helper = require('../helper');\nconst stringIncludes = require('../assert/include').includes;\nconst urlEquals = require('../assert/equal').urlEquals;\nconst equals = require('../assert/equal').equals;\nconst empty = require('../assert/empty').empty;\nconst truth = require('../assert/truth').truth;\nconst xpathLocator = require('../utils').xpathLocator;\nconst hashCode = require('../utils').hashCode;\nconst fileExists = require('../utils').fileExists;\nconst assert = require('assert');\nconst path = require('path');\nconst requireg = require('requireg');\n\nlet withinStore = {};\n\n/**\n * WebDriverIO helper which wraps [webdriverio](http://webdriver.io/) library to\n * manipulate browser using Selenium WebDriver or PhantomJS.\n *\n * #### Selenium Installation\n *\n * 1. Download [Selenium Server](http://docs.seleniumhq.org/download/)\n * 2. For Chrome browser install [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/getting-started), for Firefox browser install [GeckoDriver](https://github.com/mozilla/geckodriver).\n * 3. Launch the server: `java -jar selenium-server-standalone-3.xx.xxx.jar`. To locate Chromedriver binary use `-Dwebdriver.chrome.driver=./chromedriver` option. For Geckodriver use `-Dwebdriver.gecko.driver=`.\n *\n * #### PhantomJS Installation\n *\n * PhantomJS is a headless alternative to Selenium Server that implements the WebDriver protocol.\n * It allows you to run Selenium tests on a server without a GUI installed.\n *\n * 1. Download [PhantomJS](http://phantomjs.org/download.html)\n * 2. Run PhantomJS in WebDriver mode: `phantomjs --webdriver=4444`\n *\n * ### Configuration\n *\n * This helper should be configured in codecept.json\n *\n * * `url` - base url of website to be tested\n * * `browser` - browser in which perform testing\n * * `restart` (optional, default: true) - restart browser between tests.\n * * `keepCookies` (optional, default: false)  - keep cookies between tests when `restart` set to false.\n * * `windowSize`: (optional) default window size. Set to `maximize` or a dimension in the format `640x480`.\n * * `waitForTimeout`: (option) sets default wait time in *ms* for all `wait*` functions. 1000 by default;\n * * `desiredCapabilities`: Selenium's [desired capabilities](https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities)\n * * `manualStart` (optional, default: false) - do not start browser before a test, start it manually inside a helper with `this.helpers[\"WebDriverIO\"]._startBrowser()`\n * * `timeouts`: [WebDriverIO timeouts](http://webdriver.io/guide/testrunner/timeouts.html) defined as hash.\n *\n * Example:\n *\n * ```json\n * {\n *    \"helpers\": {\n *      \"WebDriverIO\" : {\n *        \"browser\": \"chrome\",\n *        \"restart\": false,\n *        \"windowSize\": \"maximize\",\n *        \"timeouts\": {\n *          \"script\": 60000,\n *          \"page load\": 10000,\n *          \"implicit\" : 5000\n *        }\n *      }\n *    }\n * }\n *\n * ```\n *\n * Additional configuration params can be used from [webdriverio website](http://webdriver.io/guide/getstarted/configuration.html).\n *\n * ### Connect through proxy\n *\n * CodeceptJS also provides flexible options when you want to execute tests to Selenium servers through proxy. You will\n * need to update the `helpers.WebDriverIO.desiredCapabilities.proxy` key.\n *\n * ```js\n * {\n *     \"helpers\": {\n *         \"WebDriverIO\": {\n *             \"desiredCapabilities\": {\n *                 \"proxy\": {\n *                     \"proxyType\": \"manual|pac\",\n *                     \"proxyAutoconfigUrl\": \"URL TO PAC FILE\",\n *                     \"httpProxy\": \"PROXY SERVER\",\n *                     \"sslProxy\": \"PROXY SERVER\",\n *                     \"ftpProxy\": \"PROXY SERVER\",\n *                     \"socksProxy\": \"PROXY SERVER\",\n *                     \"socksUsername\": \"USERNAME\",\n *                     \"socksPassword\": \"PASSWORD\",\n *                     \"noProxy\": \"BYPASS ADDRESSES\"\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n * For example,\n *\n * ```js\n * {\n *     \"helpers\": {\n *         \"WebDriverIO\": {\n *             \"desiredCapabilities\": {\n *                 \"proxy\": {\n *                     \"proxyType\": \"manual\",\n *                     \"httpProxy\": \"http://corporate.proxy:8080\",\n *                     \"socksUsername\": \"codeceptjs\",\n *                     \"socksPassword\": \"secret\",\n *                     \"noProxy\": \"127.0.0.1,localhost\"\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * Please refer to [Selenium - Proxy Object](https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities) for more information.\n *\n * ### Cloud Providers\n *\n * WebDriverIO makes it possible to execute tests against services like `Sauce Labs` `BrowserStack` `TestingBot`\n * Check out their documentation on [available parameters](http://webdriver.io/guide/usage/cloudservices.html)\n *\n * Connecting to `BrowserStack` and `Sauce Labs` is simple. All you need to do\n * is set the `user` and `key` parameters. WebDriverIO automatically know which\n * service provider to connect to.\n *\n * ```js\n * {\n *     \"helpers\":{\n *         \"WebDriverIO\": {\n *             \"url\": \"YOUR_DESIERED_HOST\",\n *             \"user\": \"YOUR_BROWSERSTACK_USER\",\n *             \"key\": \"YOUR_BROWSERSTACK_KEY\",\n *             \"desiredCapabilities\": {\n *                 \"browserName\": \"chrome\",\n *\n *                 // only set this if you're using BrowserStackLocal to test a local domain\n *                 // \"browserstack.local\": true,\n *\n *                 // set this option to tell browserstack to provide addition debugging info\n *                 // \"browserstack.debug\": true,\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * ### Multiremote Capabilities\n *\n * This is a work in progress but you can control two browsers at a time right out of the box.\n * Individual control is something that is planned for a later version.\n *\n * Here is the [webdriverio docs](http://webdriver.io/guide/usage/multiremote.html) on the subject\n *\n * ```js\n * {\n *     \"helpers\": {\n *         \"WebDriverIO\": {\n *             \"multiremote\": {\n *                 \"MyChrome\": {\n *                     \"desiredCapabilities\": {\n *                         \"browserName\": \"chrome\"\n *                      }\n *                 },\n *                 \"MyFirefox\": {\n *                    \"desiredCapabilities\": {\n *                        \"browserName\": \"firefox\"\n *                    }\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n *\n * ## Access From Helpers\n *\n * Receive a WebDriverIO client from a custom helper by accessing `browser` property:\n *\n * ```js\n * this.helpers['WebDriverIO'].browser\n * ```\n */\nclass WebDriverIO extends Helper {\n\n  constructor(config) {\n    super(config);\n    webdriverio = requireg('webdriverio');\n\n    // set defaults\n    this.options = {\n      waitForTimeout: 1000, // ms\n      desiredCapabilities: {},\n      restart: true,\n      uniqueScreenshotNames: false,\n      manualStart: false,\n      keepCookies: false,\n      timeouts: {\n        script: 1000 // ms\n      }\n    };\n\n    // override defaults with config\n    Object.assign(this.options, config);\n\n    this.options.baseUrl = this.options.url || this.options.baseUrl;\n    this.options.desiredCapabilities.browserName = this.options.browser || this.options.desiredCapabilities.browserName;\n    this.options.waitForTimeout /= 1000; // convert to seconds\n\n    if (!this.options.url || !this.options.browser) {\n      throw new Error(`\n        WebDriverIO requires ares.valuet least these parameters\n        Check your codeceptjs config file to ensure these are set properly\n          {\n            \"helpers\": {\n              \"WebDriverIO\": {\n                \"url\": \"YOUR_HOST\"\n                \"browser\": \"YOUR_PREFERED_TESTING_BROWSER\"\n              }\n            }\n          }\n      `);\n    }\n  }\n\n  static _checkRequirements() {\n    try {\n      requireg(\"webdriverio\");\n    } catch (e) {\n      return [\"webdriverio\"];\n    }\n  }\n\n  static _config() {\n    return [{\n      name: 'url',\n      message: \"Base url of site to be tested\",\n      default: 'http://localhost'\n    }, {\n      name: 'browser',\n      message: 'Browser in which testing will be performed',\n      default: 'chrome'\n    }];\n  }\n\n  _beforeSuite() {\n    if (!this.options.restart && !this.options.manualStart) {\n      this.debugSection('Session', 'Starting singleton browser session');\n      return this._startBrowser();\n    }\n  }\n\n  _startBrowser() {\n    if (this.options.multiremote) {\n      this.browser = webdriverio.multiremote(this.options.multiremote).init();\n    } else {\n      this.browser = webdriverio.remote(this.options).init();\n    }\n\n    if (this.options.timeouts) {\n      this.defineTimeout(this.options.timeouts);\n    }\n\n    if (this.options.windowSize === 'maximize') {\n      this.browser.windowHandleMaximize(false);\n    }\n    if (this.options.windowSize && this.options.windowSize.indexOf('x') > 0) {\n      let dimensions = this.options.windowSize.split('x');\n      this.browser.windowHandleSize({\n        width: dimensions[0],\n        height: dimensions[1]\n      });\n    }\n    return this.browser;\n  }\n\n  _before() {\n    if (this.options.restart && !this.options.manualStart) this._startBrowser();\n    this.failedTestName = null;\n    this.context = 'body';\n    return this.browser;\n  }\n\n  _after() {\n    if (this.options.restart) return this.browser.end();\n    if (this.options.keepCookies) return;\n    this.debugSection('Session', 'cleaning cookies and localStorage');\n    return this.browser.execute('localStorage.clear();').then(() => {\n      return this.browser.deleteCookie();\n    });\n  }\n\n  _afterSuite() {\n    if (!this.options.restart) return this.browser.end();\n  }\n\n  _failed(test) {\n    let fileName = '';\n    if (this.options.uniqueScreenshotNames) {\n      fileName = test.title.substring(0, 10).replace(/ /g, '_') + '-' + hashCode(test.title) + '-' + hashCode(test.file) + '.failed.png';\n    } else {\n      fileName = test.title.replace(/ /g, '_') + '.failed.png';\n    }\n    return this.saveScreenshot(fileName);\n  }\n\n  _withinBegin(locator) {\n    let frame = isFrameLocator(locator);\n    if (frame) {\n      withinStore.frame = frame;\n      return this.browser.element(frame).then((res) => this.browser.frame(res.value));\n    }\n    withinStore.elFn = this.browser.element;\n    withinStore.elsFn = this.browser.elements;\n    this.context = locator;\n    return this.browser.element(withStrictLocator(locator)).then((res) => {\n      this.browser.element = function (l) {\n        return this.elementIdElement(res.value.ELEMENT, l);\n      };\n      this.browser.elements = function (l) {\n        return this.elementIdElements(res.value.ELEMENT, l);\n      };\n    });\n  }\n\n  _withinEnd() {\n    if (withinStore.frame) {\n      withinStore = {};\n      return this.browser.frame(null);\n    }\n    this.context = 'body';\n    this.browser.element = withinStore.elFn;\n    this.browser.elements = withinStore.elsFn;\n    withinStore = {};\n  }\n\n  /**\n   * Get elements by different locator types, including strict locator\n   * Should be used in custom helpers:\n   *\n   * ```js\n   * this.helpers['WebDriverIO']._locate({name: 'password'}).then //...\n   * ```\n   */\n  _locate(locator) {\n    return this.browser.elements(withStrictLocator(locator));\n  }\n\n  /**\n   * Find a checkbox by providing human readable text:\n   *\n   * ```js\n   * this.helpers['WebDriverIO']._locateCheckable('I agree with terms and conditions').then // ...\n   * ```\n   */\n  _locateCheckable(locator) {\n    return findCheckable(this.browser, locator).then(function (res) {\n      return res.value;\n    });\n  }\n\n  /**\n   * Find a clickable element by providing human readable text:\n   *\n   * ```js\n   * this.helpers['WebDriverIO']._locateClickable('Next page').then // ...\n   * ```\n   */\n  _locateClickable(locator) {\n    return findClickable(this.browser, locator).then(function (res) {\n      return res.value;\n    });\n  }\n\n  /**\n   * Find field elements by providing human readable text:\n   *\n   * ```js\n   * this.helpers['WebDriverIO']._locateFields('Your email').then // ...\n   * ```\n   */\n  _locateFields(locator) {\n    return findFields(this.browser, locator).then(function (res) {\n      return res.value;\n    });\n  }\n\n  /**\n   * Set [WebDriverIO timeouts](http://webdriver.io/guide/testrunner/timeouts.html) in realtime.\n   * Timeouts are expected to be passed as object:\n   *\n   * ```js\n   * I.defineTimeout({ script: 5000 });\n   * I.defineTimeout({ implicit: 10000, \"page load\": 10000, script: 5000 });\n   * ```\n   */\n  defineTimeout(timeouts) {\n    if (timeouts.implicit) {\n      this.browser.timeouts('implicit', timeouts.implicit);\n    }\n    if (timeouts['page load']) {\n      this.browser.timeouts('page load', timeouts['page load']);\n    }\n    if (timeouts.script) {\n      this.browser.timeouts('script', timeouts.script);\n    }\n  }\n\n  /**\n   * {{> ../webapi/amOnPage }}\n   */\n  amOnPage(url) {\n    return this.browser.url(url).url((err, res) => {\n      if (err) throw err;\n      this.debugSection('Url', res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/click }}\n   */\n  click(locator, context) {\n    let client = this.browser;\n    let clickMethod = this.browser.isMobile ? 'touchClick' : 'elementIdClick';\n    if (context) {\n      client = client.element(context);\n    }\n    return findClickable(client, locator).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        if (typeof locator === \"object\") locator = JSON.stringify(locator);\n        throw new Error(`Clickable element ${locator.toString()} was not found by text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return this[clickMethod](elem.ELEMENT);\n    });\n  }\n\n  /**\n   * {{> ../webapi/doubleClick }}\n   */\n  doubleClick(locator, context) {\n    let client = this.browser;\n    if (context) {\n      client = client.element(context);\n    }\n    return findClickable(client, locator).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        if (typeof locator === \"object\") locator = JSON.stringify(locator);\n        throw new Error(`Clickable element ${locator.toString()} was not found by text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return this.moveTo(elem.ELEMENT).doDoubleClick();\n    });\n  }\n\n  /**\n   * Performs right click on an element matched by CSS or XPath.\n   */\n  rightClick(locator) {\n    return this.browser.rightClick(withStrictLocator(locator));\n  }\n\n  /**\n   * {{> ../webapi/fillField }}\n   */\n  fillField(field, value) {\n    return findFields(this.browser, field).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return this.elementIdClear(elem.ELEMENT).elementIdValue(elem.ELEMENT, value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/appendField }}\n   */\n  appendField(field, value) {\n    return findFields(this.browser, field).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return this.elementIdValue(elem.ELEMENT, value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/selectOption}}\n   *\n   */\n  selectOption(select, option) {\n    return findFields(this.browser, select).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        throw new Error(`Selectable field ${select} not found by name|text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n\n      let normalized, byVisibleText;\n      let commands = [];\n\n      if (!Array.isArray(option)) {\n        option = [option];\n      }\n\n      option.forEach((opt) => {\n        normalized = `[normalize-space(.) = \"${opt.trim() }\"]`;\n        byVisibleText = `./option${normalized}|./optgroup/option${normalized}`;\n        commands.push(this.elementIdElements(elem.ELEMENT, byVisibleText));\n      });\n      return this.unify(commands, {\n        extractValue: true\n      }).then((els) => {\n        commands = [];\n        let clickOptionFn = (el) => {\n          if (el[0]) el = el[0];\n          if (el && el.ELEMENT) commands.push(this.elementIdClick(el.ELEMENT));\n        };\n\n        if (els.length) {\n          els.forEach(clickOptionFn);\n          return this.unify(commands);\n        }\n        let normalized, byValue;\n\n        option.forEach((opt) => {\n          normalized = `[normalize-space(@value) = \"${opt.trim() }\"]`;\n          byValue = `./option${normalized}|./optgroup/option${normalized}`;\n          commands.push(this.elementIdElements(elem.ELEMENT, byValue));\n        });\n        // try by value\n        return this.unify(commands, {\n          extractValue: true\n        }).then((els) => {\n          if (els.length === 0) {\n            throw new Error(`Option ${option} in ${select} was found neither by visible text not by value`);\n          }\n          commands = [];\n          els.forEach(clickOptionFn);\n          return this.unify(commands);\n        });\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/attachFile }}\n   */\n  attachFile(locator, pathToFile) {\n    let file = path.join(global.codecept_dir, pathToFile);\n    if (!fileExists(file)) {\n      throw new Error(`File at ${file} can not be found on local system`);\n    }\n    return findFields(this.browser, locator).then((el) => {\n      this.debug(\"Uploading \" + file);\n      return this.browser.uploadFile(file).then((res) => {\n        if (!el.value || el.value.length === 0) {\n          throw new Error(`File field ${locator} not found by name|text|CSS|XPath`);\n        }\n        return this.browser.elementIdValue(el.value[0].ELEMENT, res.value);\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/checkOption }}\n   */\n  checkOption(field, context) {\n    let client = this.browser;\n    let clickMethod = this.browser.isMobile ? 'touchClick' : 'elementIdClick';\n    if (context) {\n      client = client.element(withStrictLocator(context));\n    }\n    return findCheckable(client, field).then((res) => {\n      if (!res.value || res.value.length === 0) {\n        throw new Error(`Checkable ${field} cant be located by name|text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return client.elementIdSelected(elem.ELEMENT).then(function (isSelected) {\n        if (isSelected.value) return true;\n        return this[clickMethod](elem.ELEMENT);\n      });\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabTextFrom }}\n   */\n  grabTextFrom(locator) {\n    return this.browser.getText(withStrictLocator(locator)).then(function (text) {\n      return text;\n    });\n  }\n\n  /**\n   * Retrieves the innerHTML from an element located by CSS or XPath and returns it to test.\n   * Resumes test execution, so **should be used inside a generator with `yield`** operator.\n   *\n   * ```js\n   * let postHTML = yield I.grabHTMLFrom('#post');\n   * ```\n   */\n  grabHTMLFrom(locator) {\n    return this.browser.getHTML(withStrictLocator(locator)).then(function (html) {\n      return html;\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabValueFrom }}\n   */\n  grabValueFrom(locator) {\n    return this.browser.getValue(withStrictLocator(locator)).then(function (text) {\n      return text;\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabAttributeFrom }}\n   */\n  grabAttributeFrom(locator, attr) {\n    return this.browser.getAttribute(withStrictLocator(locator), attr).then(function (text) {\n      return text;\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInTitle }}\n   */\n  seeInTitle(text) {\n    return this.browser.getTitle().then((title) => {\n      return stringIncludes('web page title').assert(text, title);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInTitle }}\n   */\n  dontSeeInTitle(text) {\n    return this.browser.getTitle().then((title) => {\n      return stringIncludes('web page title').negate(text, title);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabTitle }}\n   */\n  grabTitle() {\n    return this.browser.getTitle().then((title) => {\n      this.debugSection('Title', title);\n      return title;\n    });\n  }\n\n  /**\n   * {{> ../webapi/see }}\n   */\n  see(text, context) {\n    return proceedSee.call(this, 'assert', text, context);\n  }\n\n  /**\n   * {{> ../webapi/dontSee }}\n   */\n  dontSee(text, context) {\n    return proceedSee.call(this, 'negate', text, context);\n  }\n\n  /**\n   * {{> ../webapi/seeInField }}\n   */\n  seeInField(field, value) {\n    return proceedSeeField.call(this, 'assert', field, value);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInField }}\n   */\n  dontSeeInField(field, value) {\n    return proceedSeeField.call(this, 'negate', field, value);\n  }\n\n  /**\n   * {{> ../webapi/seeCheckboxIsChecked }}\n   */\n  seeCheckboxIsChecked(field) {\n    return proceedSeeCheckbox.call(this, 'assert', field);\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCheckboxIsChecked }}\n   */\n  dontSeeCheckboxIsChecked(field) {\n    return proceedSeeCheckbox.call(this, 'negate', field);\n  }\n\n  /**\n   * {{> ../webapi/seeElement }}\n   */\n  seeElement(locator) {\n    return this.browser.isVisible(withStrictLocator(locator)).then(function (res) {\n      return truth(`elements of ${locator}`, 'to be seen').assert(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElement}}\n   */\n  dontSeeElement(locator) {\n    return this.browser.isVisible(withStrictLocator(locator)).then(function (res) {\n      return truth(`elements of ${locator}`, 'to be seen').negate(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeElementInDOM }}\n   */\n  seeElementInDOM(locator) {\n    return this.browser.elements(withStrictLocator(locator)).then(function (res) {\n      return empty('elements').negate(res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeElementInDOM }}\n   */\n  dontSeeElementInDOM(locator) {\n    return this.browser.elements(withStrictLocator(locator)).then(function (res) {\n      return empty('elements').assert(res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeInSource }}\n   */\n  seeInSource(text) {\n    return this.browser.getSource().then((source) => {\n      return stringIncludes('HTML source of a page').assert(text, source);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInSource }}\n   */\n  dontSeeInSource(text) {\n    return this.browser.getSource().then((source) => {\n      return stringIncludes('HTML source of a page').negate(text, source);\n    });\n  }\n\n  /**\n   * asserts that an element appears a given number of times in the DOM\n   * Element is located by label or name or CSS or XPath.\n   *\n   * ```js\n   * I.seeNumberOfElements('#submitBtn', 1);\n   * ```\n   */\n  seeNumberOfElements(selector, num) {\n    return this.browser.elements(withStrictLocator(selector))\n      .then(function (res) {\n        return assert.equal(res.value.length, num);\n      });\n  }\n\n  /**\n   * asserts that an element is visible a given number of times\n   * Element is located by CSS or XPath.\n   *\n   * ```js\n   * I.seeNumberOfVisibleElements('.buttons', 3);\n   * ```\n   */\n  seeNumberOfVisibleElements(selector, num) {\n    return this.browser.isVisible(withStrictLocator(selector))\n      .then(function (res) {\n        if(!Array.isArray(res)) res = [res];\n        res = res.filter((val) => val == true);\n        return truth(`elements of ${locator}`, 'to be seen').assert.equal(res.length, num);\n      });\n  }\n\n  /**\n   * {{> ../webapi/seeInCurrentUrl }}\n   */\n  seeInCurrentUrl(url) {\n    return this.browser.url().then(function (res) {\n      return stringIncludes('url').assert(url, res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeInCurrentUrl }}\n   */\n  dontSeeInCurrentUrl(url) {\n    return this.browser.url().then(function (res) {\n      return stringIncludes('url').negate(url, res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/seeCurrentUrlEquals }}\n   */\n  seeCurrentUrlEquals(url) {\n    return this.browser.url().then((res) => {\n      return urlEquals(this.options.url).assert(url, res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCurrentUrlEquals }}\n   */\n  dontSeeCurrentUrlEquals(url) {\n    return this.browser.url().then((res) => {\n      return urlEquals(this.options.url).negate(url, res.value);\n    });\n  }\n\n  /**\n   * {{> ../webapi/executeScript }}\n   *\n   * Wraps [execute](http://webdriver.io/api/protocol/execute.html) command.\n   */\n  executeScript(fn) {\n    return this.browser.execute.apply(this.browser, arguments).then((res) => res.value);\n  }\n\n  /**\n   * {{> ../webapi/executeAsyncScript }}\n   */\n  executeAsyncScript(fn) {\n    return this.browser.executeAsync.apply(this.browser, arguments).then((res) => res.value);\n  }\n\n  /**\n   * Scrolls to element matched by locator.\n   * Extra shift can be set with offsetX and offsetY options\n   *\n   * ```js\n   * I.scrollTo('footer');\n   * I.scrollTo('#submit', 5,5);\n   * ```\n   */\n  scrollTo(locator, offsetX, offsetY) {\n    return this.browser.scroll(withStrictLocator(locator), offsetX, offsetY);\n  }\n\n  /**\n   * {{> ../webapi/moveCursorTo}}\n   */\n  moveCursorTo(locator, offsetX, offsetY) {\n    return this.browser.moveToObject(withStrictLocator(locator), offsetX, offsetY);\n  }\n\n  /**\n   * {{> ../webapi/saveScreenshot}}\n   */\n  saveScreenshot(fileName) {\n    let outputFile = path.join(global.output_dir, fileName);\n    this.debug('Screenshot has been saved to ' + outputFile);\n    return this.browser.saveScreenshot(outputFile);\n  }\n\n  /**\n   * {{> ../webapi/setCookie}}\n   *\n   * Uses Selenium's JSON [cookie format](https://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object).\n   */\n  setCookie(cookie) {\n    return this.browser.setCookie(cookie);\n  }\n\n  /**\n   * {{> ../webapi/clearCookie}}\n   */\n  clearCookie(cookie) {\n    return this.browser.deleteCookie(cookie);\n  }\n\n  /**\n   * {{> ../webapi/clearField}}\n   */\n  clearField(field) {\n    return findFields(this.browser, field).then(function (res) {\n      if (!res.value || res.value.length === 0) {\n        throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n      }\n      let elem = res.value[0];\n      return this.elementIdClear(elem.ELEMENT);\n    });\n\n  }\n\n  /**\n   * {{> ../webapi/seeCookie}}\n   */\n  seeCookie(name) {\n    return this.browser.getCookie(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').assert(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/dontSeeCookie}}\n   */\n  dontSeeCookie(name) {\n    return this.browser.getCookie(name).then(function (res) {\n      return truth('cookie ' + name, 'to be set').negate(res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/grabCookie}}\n   */\n  grabCookie(name) {\n    return this.browser.getCookie(name);\n  }\n\n  /**\n   * Accepts the active JavaScript native popup window, as created by window.alert|window.confirm|window.prompt.\n   * Don't confuse popups with modal windows, as created by [various libraries](http://jster.net/category/windows-modals-popups).\n   */\n  acceptPopup() {\n    return this.browser.alertText().then(function (res) {\n      if (res !== null) {\n        return this.alertAccept();\n      }\n    });\n  }\n\n  /**\n   * Dismisses the active JavaScript popup, as created by window.alert|window.confirm|window.prompt.\n   */\n  cancelPopup() {\n    return this.browser.alertText().then(function (res) {\n      if (res !== null) {\n        return this.alertDismiss();\n      }\n    });\n  }\n\n  /**\n   * Checks that the active JavaScript popup, as created by `window.alert|window.confirm|window.prompt`, contains the given string.\n   */\n  seeInPopup(text) {\n    return this.browser.alertText().then(function (res) {\n      if (res === null) {\n        throw new Error('Popup is not opened');\n      }\n      stringIncludes('text in popup').assert(text, res);\n    });\n  }\n\n  /**\n   * {{> ../webapi/pressKey }}\n   *\n   * To make combinations with modifier and mouse clicks (like Ctrl+Click) press a modifier, click, then release it.\n   *\n   * ```js\n   * I.pressKey('Control');\n   * I.click('#someelement');\n   * I.pressKey('Control');\n   * ```\n   */\n  pressKey(key) {\n    let modifier;\n    if (Array.isArray(key) && ~['Control', 'Command', 'Shift', 'Alt'].indexOf(key[0])) {\n      modifier = key[0];\n    }\n    return this.browser.keys(key).then(function () {\n      if (!modifier) return true;\n      return this.keys(modifier); // release modifeier\n    });\n  }\n\n  /**\n   * {{> ../webapi/resizeWindow }}\n   */\n  resizeWindow(width, height) {\n    if (width === 'maximize') {\n      return this.browser.windowHandleMaximize(false);\n    }\n    return this.browser.windowHandleSize({\n      width,\n      height\n    });\n  }\n\n  /**\n   * Drag an item to a destination element.\n   *\n   * ```js\n   * I.dragAndDrop('#dragHandle', '#container');\n   * ```\n   */\n  dragAndDrop(srcElement, destElement) {\n    return this.browser.dragAndDrop(\n      withStrictLocator(srcElement),\n      withStrictLocator(destElement)\n    );\n  }\n\n  /**\n   * {{> ../webapi/wait }}\n   */\n  wait(sec) {\n    return this.browser.pause(sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForEnabled }}\n   */\n  waitForEnabled(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitForEnabled(withStrictLocator(locator), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForElement }}\n   */\n  waitForElement(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitForExist(withStrictLocator(locator), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForText }}\n   */\n  waitForText(text, sec, context) {\n    sec = sec || this.options.waitForTimeout;\n    context = context || 'body';\n    return this.browser.waitUntil(function () {\n      return this.getText(context).then(function (source) {\n        if (Array.isArray(source)) {\n          return source.filter(part => part.indexOf(text) >= 0).length > 0;\n        }\n        return source.indexOf(text) >= 0;\n      });\n    }, sec * 1000)\n      .catch((e) => {\n        if (e.type === 'WaitUntilTimeoutError') {\n          return proceedSee.call(this, 'assert', text, context);\n        } else {\n          throw e;\n        }\n      });\n  }\n\n  /**\n   * {{> ../webapi/waitForVisible }}\n   */\n  waitForVisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitForVisible(withStrictLocator(locator), sec * 1000);\n  }\n\n  /**\n   * {{> ../webapi/waitForInvisible }}\n   */\n  waitForInvisible(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitForVisible(withStrictLocator(locator), sec * 1000, true);\n  }\n\n  /**\n   * Waits for an element to become invisible on a page (by default waits for 1sec).\n   * Element can be located by CSS or XPath.\n   */\n  waitToHide(locator, sec) {\n    return this.waitForInvisible(locator, sec);\n  }\n\n  /**\n   * {{> ../webapi/waitForStalenessOf }}\n   */\n  waitForStalenessOf(locator, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitForExist(withStrictLocator(locator), sec * 1000, true);\n  }\n\n  /**\n   * Waits for a function to return true (waits for 1sec by default).\n   */\n  waitUntil(fn, sec) {\n    sec = sec || this.options.waitForTimeout;\n    return this.browser.waitUntil(fn, sec);\n  }\n\n  /**\n   * Switches frame or in case of null locator reverts to parent.\n   */\n  switchTo(locator) {\n    locator = locator || null;\n    return this.browser.frame(locator);\n  }\n}\n\nfunction proceedSee(assertType, text, context) {\n  let description;\n  if (!context) {\n    context = this.context;\n    if (this.context === 'body') {\n      description = 'web page';\n    } else {\n      description = 'current context ' + this.context;\n    }\n  } else {\n    description = 'element ' + context;\n  }\n  return this.browser.getText(withStrictLocator(context)).then(function (source) {\n    return stringIncludes(description)[assertType](text, source);\n  });\n}\n\nfunction findClickable(client, locator) {\n  if (typeof locator === 'object') return client.elements(withStrictLocator(locator));\n  if (isCSSorXPathLocator(locator)) return client.elements(locator);\n\n  let literal = xpathLocator.literal(locator);\n\n  let narrowLocator = xpathLocator.combine([\n    `.//a[normalize-space(.)=${literal}]`,\n    `.//button[normalize-space(.)=${literal}]`,\n    `.//a/img[normalize-space(@alt)=${literal}]/ancestor::a`,\n    `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][normalize-space(@value)=${literal}]`\n  ]);\n  return client.elements(narrowLocator).then(function (els) {\n    if (els.value.length) {\n      return els;\n    }\n    let wideLocator = xpathLocator.combine([\n      `.//a[./@href][((contains(normalize-space(string(.)), ${literal})) or .//img[contains(./@alt, ${literal})])]`,\n      `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][contains(./@value, ${literal})]`,\n      `.//input[./@type = 'image'][contains(./@alt, ${literal})]`,\n      `.//button[contains(normalize-space(string(.)), ${literal})]`,\n      `.//input[./@type = 'submit' or ./@type = 'image' or ./@type = 'button'][./@name = ${literal}]`,\n      `.//button[./@name = ${literal}]`\n    ]);\n    return client.elements(wideLocator).then(function (els) {\n      if (els.value.length) {\n        return els;\n      }\n      return client.elements(locator); // by css or xpath\n    });\n  });\n}\n\nfunction findFields(client, locator) {\n  if (typeof locator === 'object') return client.elements(withStrictLocator(locator));\n  if (isCSSorXPathLocator(locator)) return client.elements(locator);\n\n  let literal = xpathLocator.literal(locator);\n  let byText = xpathLocator.combine([\n    `.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')][(((./@name = ${literal}) or ./@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or ./@placeholder = ${literal})]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//.//*[self::input | self::textarea | self::select][not(./@type = 'submit' or ./@type = 'image' or ./@type = 'hidden')]`\n  ]);\n  return client.elements(byText).then((els) => {\n    if (els.value.length) return els;\n    let byName = `.//*[self::input | self::textarea | self::select][@name = ${literal}]`;\n    return client.elements(byName).then((els) => {\n      if (els.value.length) return els;\n      return client.elements(locator); // by css or xpath\n    });\n  });\n}\n\nfunction proceedSeeField(assertType, field, value) {\n  return findFields(this.browser, field).then(function (res) {\n    if (!res.value || res.value.length === 0) {\n      throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n    }\n\n    var proceedMultiple = (fields) => {\n      let commands = [];\n      fields.forEach((el) => commands.push(this.elementIdSelected(el.ELEMENT)));\n      this.unify(commands).then((res) => {\n        commands = [];\n        fields.forEach((el) => {\n          if (el.value === false) return;\n          commands.push(this.elementIdAttribute(el.ELEMENT, 'value'));\n        });\n        this.unify(commands, {\n          extractValue: true\n        }).then((val) => {\n          return stringIncludes('fields by ' + field)[assertType](value, val);\n        });\n      });\n    };\n\n    var proceedSingle = (el) => {\n      return this.elementIdAttribute(el.ELEMENT, 'value').then((res) => {\n        return stringIncludes('fields by ' + field)[assertType](value, res.value);\n      });\n    };\n\n    return this.elementIdName(res.value[0].ELEMENT).then((tag) => {\n      if (tag.value == 'select') {\n        return proceedMultiple(res.value);\n      }\n\n      if (tag.value == 'input') {\n        return this.elementIdAttribute(res.value[0].ELEMENT, 'type').then((type) => {\n          if (type.value == 'checkbox' || type.value == 'radio') {\n            return proceedMultiple(res.value);\n          }\n          return proceedSingle(res.value[0]);\n        });\n      }\n      return proceedSingle(res.value[0]);\n    });\n  });\n}\n\nfunction proceedSeeCheckbox(assertType, field) {\n  return findFields(this.browser, field).then(function (res) {\n    if (!res.value || res.value.length === 0) {\n      throw new Error(`Field ${field} not found by name|text|CSS|XPath`);\n    }\n    let commands = [];\n    res.value.forEach((el) => commands.push(this.elementIdSelected(el.ELEMENT)));\n    return this.unify(commands, {\n      extractValue: true\n    }).then((selected) => {\n      return truth(`checkable field ${field}`, 'to be checked')[assertType](selected);\n    });\n  });\n}\n\nfunction findCheckable(client, locator) {\n  if (typeof locator === 'object') return client.elements(withStrictLocator(locator));\n  if (isCSSorXPathLocator(locator)) return client.elements(locator);\n\n  let literal = xpathLocator.literal(locator);\n  let byText = xpathLocator.combine([\n    `.//input[@type = 'checkbox' or @type = 'radio'][(@id = //label[contains(normalize-space(string(.)), ${literal})]/@for) or @placeholder = ${literal}]`,\n    `.//label[contains(normalize-space(string(.)), ${literal})]//input[@type = 'radio' or @type = 'checkbox']`\n  ]);\n  return client.elements(byText).then(function (els) {\n    if (els.value.length) return els;\n    let byName = `.//input[@type = 'checkbox' or @type = 'radio'][@name = ${literal}]`;\n    return client.elements(byName).then(function (els) {\n      if (els.value.length) return els;\n      return client.elements(locator); // by css or xpath\n    });\n  });\n}\n\nfunction isCSSorXPathLocator(locator) {\n  if (locator[0] === '#' || locator[0] === '.') {\n    return true;\n  }\n  if (locator.substr(0, 2) === '//') {\n    return true;\n  }\n  return false;\n}\n\nfunction withStrictLocator(locator) {\n  if (!locator) return null;\n  if (typeof locator !== 'object') return locator;\n  let key = Object.keys(locator)[0];\n  let value = locator[key];\n\n  locator.toString = () => `{${key}: '${value}'}`;\n\n  switch (key) {\n  case 'by':\n  case 'xpath':\n  case 'css':\n    return value;\n  case 'id':\n    return '#' + value;\n  case 'name':\n    return `[name=\"${value}\"]`;\n  }\n}\n\nfunction isFrameLocator(locator) {\n  if (typeof locator !== 'object') return false;\n  let key = Object.keys(locator)[0];\n  if (key !== 'frame') return false;\n  return locator[key];\n}\n\nmodule.exports = WebDriverIO;\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/interfaces/bdd.js":"/**\n * Module dependencies.\n */\n\nvar Suite = require('mocha/lib/suite');\nvar Test = require('mocha/lib/test');\nvar event = require('../event');\nvar scenario = require('../scenario');\nvar recorder = require('../recorder');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * Codecept-style interface:\n *\n * Feature('login')\n * Scenario('login as regular user', (I) {\n *   I.fillField();\n *   I.click()\n *   I.see('Hello, '+data.login);\n * });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n  suite.timeout(0);\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('mocha/lib/interfaces/common')(suites, context);\n\n    // create dispatcher\n\n    context.BeforeAll = common.before;\n    context.AfterAll = common.after;\n\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.Feature = function (title, opts) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      if (!opts) opts = {};\n      var suite = Suite.create(suites[0], title);\n      suite.timeout(0);\n\n      if (opts.retries) suite.retries(opts.retries);\n      if (opts.timeout) suite.timeout(opts.timeout);\n\n      suite.file = file;\n      suites.unshift(suite);\n      suite.beforeEach('codeceptjs.before', scenario.setup);\n      suite.afterEach('finialize codeceptjs', scenario.teardown);\n\n      suite.beforeAll('codeceptjs.beforeSuite', scenario.suiteSetup);\n      suite.afterAll('codeceptjs.afterSuite', scenario.suiteTeardown);\n\n      return suite;\n    };\n\n    context.BeforeSuite = function (fn) {\n      suites[0].beforeAll('BeforeSuite', scenario.injected(fn, suites[0]));\n    };\n\n    context.AfterSuite = function (fn) {\n      suites[0].afterAll('AfterSuite', scenario.injected(fn, suites[0]));\n    };\n\n    context.Background = context.Before = function (fn) {\n      suites[0].beforeEach('Before', scenario.injected(fn, suites[0]));\n    };\n\n    context.After = function (fn) {\n      suites[0].afterEach('After', scenario.injected(fn, suites[0]));\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n    context.Scenario = function (title, opts, fn) {\n      if (typeof opts === 'function' && !fn) {\n        fn = opts;\n        opts = {};\n      }\n\n      var suite = suites[0];\n      if (suite.pending) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.fullTitle = () => `${suite.title}: ${title}`;\n      test.file = file;\n      test.async = true;\n      test.timeout(0);\n\n      if (opts.retries) test.retries(opts.retries);\n      if (opts.timeout) test.timeout(opts.timeout);\n\n      suite.addTest(scenario.test(test));\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.Scenario.only = function (title, fn) {\n      var test = context.Scenario(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    /**\n     * Pending test case.\n     */\n    context.xScenario = context.Scenario.skip = function (title) {\n      context.Scenario(title, {});\n    };\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/listener/exit.js":"'use strict';\n\nconst event = require('../event');\n\nmodule.exports = function () {\n\n  let failed = false;\n\n  let failedTests = [];\n\n  event.dispatcher.on(event.test.failed, function (testOrSuite) {\n    // NOTE When an error happens in one of the hooks (BeforeAll/BeforeEach...) the event object\n    // is a suite and not a test\n    failedTests.push(testOrSuite.fullTitle());\n  });\n\n  // if test was successful after retries\n  event.dispatcher.on(event.test.passed, function (testOrSuite) {\n    // NOTE When an error happens in one of the hooks (BeforeAll/BeforeEach...) the event object\n    // is a suite and not a test\n    failedTests = failedTests.filter((failed) => testOrSuite.fullTitle() !== failed);\n  });\n\n  event.dispatcher.on(event.all.result, function () {\n    if (failedTests.length) {\n      process.exitCode = 1;\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/listener/helpers.js":"'use strict';\n\nconst event = require('../event');\nconst container = require('../container');\nconst recorder = require('../recorder');\nconst debug = require('../output').debug;\n\n/**\n * Enable Helpers to listen to test events\n */\nmodule.exports = function () {\n  let helpers = container.helpers();\n\n  const runHelpersHook = (hook, param) => {\n    Object.keys(helpers).forEach((key) => {\n      helpers[key][hook](param);\n    });\n  };\n\n  const runAsyncHelpersHook = (hook, param, force) => {\n    Object.keys(helpers).forEach((key) => {\n      if (!helpers[key][hook]) return;\n      recorder.add(`hook ${key}.${hook}()`, () => helpers[key][hook](param), force);\n    });\n  };\n\n  event.dispatcher.on(event.all.before, function () {\n    runHelpersHook('_init');\n  });\n\n  event.dispatcher.on(event.suite.before, function (suite) {\n    runAsyncHelpersHook('_beforeSuite', null, true);\n  });\n\n  event.dispatcher.on(event.suite.after, function (suite) {\n    runAsyncHelpersHook('_afterSuite', null, true);\n  });\n\n  event.dispatcher.on(event.test.started, function (test) {\n    runHelpersHook('_test', test);\n    recorder.catch((e) => debug(e));\n  });\n\n  event.dispatcher.on(event.test.before, function () {\n    runAsyncHelpersHook('_before');\n  });\n\n  event.dispatcher.on(event.test.failed, function (test) {\n    runAsyncHelpersHook('_failed', test, true);\n    // should not fail test execution, so errors should be catched\n    recorder.catch((e) => debug(e));\n  });\n\n  event.dispatcher.on(event.test.after, function (test) {\n    runAsyncHelpersHook('_after', {}, true);\n  });\n\n  event.dispatcher.on(event.step.before, function (step) {\n    runAsyncHelpersHook('_beforeStep', step);\n  });\n\n  event.dispatcher.on(event.step.after, function (step) {\n    runAsyncHelpersHook('_afterStep', step);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/listener/steps.js":"'use strict';\nconst event = require('../event');\n\nlet currentTest;\nlet steps;\n\n/**\n * Register steps inside tests\n */\nmodule.exports = function () {\n\n  event.dispatcher.on(event.test.started, function (test) {\n    currentTest = test;\n    currentTest.steps = [];\n  });\n\n  event.dispatcher.on(event.test.after, function () {\n    currentTest = null;\n  });\n\n  event.dispatcher.on(event.test.failed, function (test) {\n    if (!currentTest) return;\n    // last step is failing step\n    if (!currentTest.steps.length) return;\n    currentTest.steps.slice(-1)[0].status = 'failed';\n  });\n\n  event.dispatcher.on(event.step.before, function (step) {\n    if (!currentTest || !currentTest.steps) return;\n    currentTest.steps.push(step);\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-codeceptjs/node_modules/codeceptjs/lib/listener/trace.js":"'use strict';\n\nconst output = require('../output');\nconst event = require('../event');\nconst AssertionFailedError = require('../assert/error');\nconst ucfirst = require('../utils').ucfirst;\n\n/**\n * Register stack trace for scenarios\n */\nmodule.exports = function () {\n\n  event.dispatcher.on(event.test.failed, function (test, err) {\n    let msg = err.message;\n    if (err instanceof AssertionFailedError) {\n      msg = err.message = err.inspect();\n    }\n    let steps = test.steps;\n    if (steps && steps.length) {\n      let scenarioTrace = \"\";\n      steps.reverse().forEach((step, i) => {\n        let line = `- ${step.toCode()} ${step.line()}`;\n        // if (step.status === 'failed') line = '' + line;\n        scenarioTrace += \"\\n\" + line;\n      });\n      msg += `\\n\\nScenario Steps:\\n${scenarioTrace}\\n\\n`;\n    }\n\n    if (output.level() < 3) {\n      err.stack = ''; // hide internal error stack trace in non-verbose mode\n    }\n\n    err.stack = msg + err.stack;\n    test.err = err;\n  });\n\n};\n\n"}